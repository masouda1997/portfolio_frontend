"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@hookform";
exports.ids = ["vendor-chunks/@hookform"];
exports.modules = {

/***/ "(ssr)/./node_modules/@hookform/devtools/dist/index.cjs.development.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@hookform/devtools/dist/index.cjs.development.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar littleStateMachine = __webpack_require__(/*! little-state-machine */ \"(ssr)/./node_modules/little-state-machine/dist/little-state-machine.es.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar uuid = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/uuid/dist/esm-node/index.js\");\nvar reactSimpleAnimate = __webpack_require__(/*! react-simple-animate */ \"(ssr)/./node_modules/react-simple-animate/dist/index.js\");\nvar styled = __webpack_require__(/*! @emotion/styled */ \"(ssr)/./node_modules/@emotion/styled/dist/emotion-styled.development.esm.js\");\nvar isUndefined$1 = __webpack_require__(/*! lodash/isUndefined */ \"(ssr)/./node_modules/lodash/isUndefined.js\");\nvar isObject$1 = __webpack_require__(/*! lodash/isObject */ \"(ssr)/./node_modules/lodash/isObject.js\");\nvar get$1 = __webpack_require__(/*! lodash/get */ \"(ssr)/./node_modules/lodash/get.js\");\nvar useDeepCompareEffect = __webpack_require__(/*! use-deep-compare-effect */ \"(ssr)/./node_modules/use-deep-compare-effect/dist/use-deep-compare-effect.esm.js\");\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function (k) {\n            if (k !== 'default') {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function () { return e[k]; }\n                });\n            }\n        });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n}\n\nvar React__default = /*#__PURE__*/_interopDefaultLegacy(React);\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\nvar styled__default = /*#__PURE__*/_interopDefaultLegacy(styled);\nvar isUndefined__default = /*#__PURE__*/_interopDefaultLegacy(isUndefined$1);\nvar isObject__default = /*#__PURE__*/_interopDefaultLegacy(isObject$1);\nvar get__default = /*#__PURE__*/_interopDefaultLegacy(get$1);\nvar useDeepCompareEffect__default = /*#__PURE__*/_interopDefaultLegacy(useDeepCompareEffect);\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nvar isDateObject = (value) => value instanceof Date;\n\nvar isNullOrUndefined = (value) => value == null;\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) &&\r\n    !Array.isArray(value) &&\r\n    isObjectType(value) &&\r\n    !isDateObject(value);\n\nvar getEventValue = (event) => isObject(event) && event.target\r\n    ? isCheckBoxInput(event.target)\r\n        ? event.target.checked\r\n        : event.target.value\r\n    : event;\n\nvar getNodeParentName = (name) => name.substring(0, name.search(/\\.\\d+(\\.|$)/)) || name;\n\nvar isNameInFieldArray = (names, name) => names.has(getNodeParentName(name));\n\nvar isPlainObject = (tempObject) => {\r\n    const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;\r\n    return (isObject(prototypeCopy) && prototypeCopy.hasOwnProperty('isPrototypeOf'));\r\n};\n\nvar isWeb = typeof window !== 'undefined' &&\r\n    typeof window.HTMLElement !== 'undefined' &&\r\n    typeof document !== 'undefined';\n\nfunction cloneObject(data) {\r\n    let copy;\r\n    const isArray = Array.isArray(data);\r\n    if (data instanceof Date) {\r\n        copy = new Date(data);\r\n    }\r\n    else if (data instanceof Set) {\r\n        copy = new Set(data);\r\n    }\r\n    else if (!(isWeb && (data instanceof Blob || data instanceof FileList)) &&\r\n        (isArray || isObject(data))) {\r\n        copy = isArray ? [] : {};\r\n        if (!Array.isArray(data) && !isPlainObject(data)) {\r\n            copy = data;\r\n        }\r\n        else {\r\n            for (const key in data) {\r\n                copy[key] = cloneObject(data[key]);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        return data;\r\n    }\r\n    return copy;\r\n}\n\nvar compact = (value) => Array.isArray(value) ? value.filter(Boolean) : [];\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj, path, defaultValue) => {\r\n    if (!path || !isObject(obj)) {\r\n        return defaultValue;\r\n    }\r\n    const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => isNullOrUndefined(result) ? result : result[key], obj);\r\n    return isUndefined(result) || result === obj\r\n        ? isUndefined(obj[path])\r\n            ? defaultValue\r\n            : obj[path]\r\n        : result;\r\n};\n\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    FOCUS_OUT: 'focusout',\r\n    CHANGE: 'change',\r\n};\r\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n    onTouched: 'onTouched',\r\n    all: 'all',\r\n};\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\n\nconst HookFormContext = React__default[\"default\"].createContext(null);\r\n/**\r\n * This custom hook allows you to access the form context. useFormContext is intended to be used in deeply nested structures, where it would become inconvenient to pass the context as a prop. To be used with {@link FormProvider}.\r\n *\r\n * @remarks\r\n * [API](https://react-hook-form.com/api/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)\r\n *\r\n * @returns return all useForm methods\r\n *\r\n * @example\r\n * ```tsx\r\n * function App() {\r\n *   const methods = useForm();\r\n *   const onSubmit = data => console.log(data);\r\n *\r\n *   return (\r\n *     <FormProvider {...methods} >\r\n *       <form onSubmit={methods.handleSubmit(onSubmit)}>\r\n *         <NestedInput />\r\n *         <input type=\"submit\" />\r\n *       </form>\r\n *     </FormProvider>\r\n *   );\r\n * }\r\n *\r\n *  function NestedInput() {\r\n *   const { register } = useFormContext(); // retrieve all hook methods\r\n *   return <input {...register(\"test\")} />;\r\n * }\r\n * ```\r\n */\r\nconst useFormContext = () => React__default[\"default\"].useContext(HookFormContext);\r\n\nvar getProxyFormState = (formState, control, localProxyFormState, isRoot = true) => {\r\n    const result = {\r\n        defaultValues: control._defaultValues,\r\n    };\r\n    for (const key in formState) {\r\n        Object.defineProperty(result, key, {\r\n            get: () => {\r\n                const _key = key;\r\n                if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {\r\n                    control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;\r\n                }\r\n                localProxyFormState && (localProxyFormState[_key] = true);\r\n                return formState[_key];\r\n            },\r\n        });\r\n    }\r\n    return result;\r\n};\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nvar shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot) => {\r\n    updateFormState(formStateData);\r\n    const { name, ...formState } = formStateData;\r\n    return (isEmptyObject(formState) ||\r\n        Object.keys(formState).length >= Object.keys(_proxyFormState).length ||\r\n        Object.keys(formState).find((key) => _proxyFormState[key] ===\r\n            (!isRoot || VALIDATION_MODE.all)));\r\n};\n\nvar convertToArrayPayload = (value) => (Array.isArray(value) ? value : [value]);\n\nvar shouldSubscribeByName = (name, signalName, exact) => exact && signalName\r\n    ? name === signalName\r\n    : !name ||\r\n        !signalName ||\r\n        name === signalName ||\r\n        convertToArrayPayload(name).some((currentName) => currentName &&\r\n            (currentName.startsWith(signalName) ||\r\n                signalName.startsWith(currentName)));\n\nfunction useSubscribe(props) {\r\n    const _props = React__default[\"default\"].useRef(props);\r\n    _props.current = props;\r\n    React__default[\"default\"].useEffect(() => {\r\n        const subscription = !props.disabled &&\r\n            _props.current.subject &&\r\n            _props.current.subject.subscribe({\r\n                next: _props.current.next,\r\n            });\r\n        return () => {\r\n            subscription && subscription.unsubscribe();\r\n        };\r\n    }, [props.disabled]);\r\n}\n\n/**\r\n * This custom hook allows you to subscribe to each form state, and isolate the re-render at the custom hook level. It has its scope in terms of form state subscription, so it would not affect other useFormState and useForm. Using this hook can reduce the re-render impact on large and complex form application.\r\n *\r\n * @remarks\r\n * [API](https://react-hook-form.com/api/useformstate) • [Demo](https://codesandbox.io/s/useformstate-75xly)\r\n *\r\n * @param props - include options on specify fields to subscribe. {@link UseFormStateReturn}\r\n *\r\n * @example\r\n * ```tsx\r\n * function App() {\r\n *   const { register, handleSubmit, control } = useForm({\r\n *     defaultValues: {\r\n *     firstName: \"firstName\"\r\n *   }});\r\n *   const { dirtyFields } = useFormState({\r\n *     control\r\n *   });\r\n *   const onSubmit = (data) => console.log(data);\r\n *\r\n *   return (\r\n *     <form onSubmit={handleSubmit(onSubmit)}>\r\n *       <input {...register(\"firstName\")} placeholder=\"First Name\" />\r\n *       {dirtyFields.firstName && <p>Field is dirty.</p>}\r\n *       <input type=\"submit\" />\r\n *     </form>\r\n *   );\r\n * }\r\n * ```\r\n */\r\nfunction useFormState(props) {\r\n    const methods = useFormContext();\r\n    const { control = methods.control, disabled, name, exact } = props || {};\r\n    const [formState, updateFormState] = React__default[\"default\"].useState(control._formState);\r\n    const _mounted = React__default[\"default\"].useRef(true);\r\n    const _localProxyFormState = React__default[\"default\"].useRef({\r\n        isDirty: false,\r\n        isLoading: false,\r\n        dirtyFields: false,\r\n        touchedFields: false,\r\n        isValidating: false,\r\n        isValid: false,\r\n        errors: false,\r\n    });\r\n    const _name = React__default[\"default\"].useRef(name);\r\n    _name.current = name;\r\n    useSubscribe({\r\n        disabled,\r\n        next: (value) => _mounted.current &&\r\n            shouldSubscribeByName(_name.current, value.name, exact) &&\r\n            shouldRenderFormState(value, _localProxyFormState.current, control._updateFormState) &&\r\n            updateFormState({\r\n                ...control._formState,\r\n                ...value,\r\n            }),\r\n        subject: control._subjects.state,\r\n    });\r\n    React__default[\"default\"].useEffect(() => {\r\n        _mounted.current = true;\r\n        const isDirty = control._proxyFormState.isDirty && control._getDirty();\r\n        if (isDirty !== control._formState.isDirty) {\r\n            control._subjects.state.next({\r\n                isDirty,\r\n            });\r\n        }\r\n        _localProxyFormState.current.isValid && control._updateValid(true);\r\n        return () => {\r\n            _mounted.current = false;\r\n        };\r\n    }, [control]);\r\n    return getProxyFormState(formState, control, _localProxyFormState.current, false);\r\n}\n\nvar isString = (value) => typeof value === 'string';\n\nvar generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue) => {\r\n    if (isString(names)) {\r\n        isGlobal && _names.watch.add(names);\r\n        return get(formValues, names, defaultValue);\r\n    }\r\n    if (Array.isArray(names)) {\r\n        return names.map((fieldName) => (isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));\r\n    }\r\n    isGlobal && (_names.watchAll = true);\r\n    return formValues;\r\n};\n\n/**\r\n * Custom hook to subscribe to field change and isolate re-rendering at the component level.\r\n *\r\n * @remarks\r\n *\r\n * [API](https://react-hook-form.com/api/usewatch) • [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)\r\n *\r\n * @example\r\n * ```tsx\r\n * const { watch } = useForm();\r\n * const values = useWatch({\r\n *   name: \"fieldName\"\r\n *   control,\r\n * })\r\n * ```\r\n */\r\nfunction useWatch(props) {\r\n    const methods = useFormContext();\r\n    const { control = methods.control, name, defaultValue, disabled, exact, } = props || {};\r\n    const _name = React__default[\"default\"].useRef(name);\r\n    _name.current = name;\r\n    useSubscribe({\r\n        disabled,\r\n        subject: control._subjects.values,\r\n        next: (formState) => {\r\n            if (shouldSubscribeByName(_name.current, formState.name, exact)) {\r\n                updateValue(cloneObject(generateWatchOutput(_name.current, control._names, formState.values || control._formValues, false, defaultValue)));\r\n            }\r\n        },\r\n    });\r\n    const [value, updateValue] = React__default[\"default\"].useState(control._getWatch(name, defaultValue));\r\n    React__default[\"default\"].useEffect(() => control._removeUnmounted());\r\n    return value;\r\n}\n\nvar isKey = (value) => /^\\w*$/.test(value);\n\nvar stringToPath = (input) => compact(input.replace(/[\"|']|\\]/g, '').split(/\\.|\\[/));\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || Array.isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria\r\n    ? {\r\n        ...errors[name],\r\n        types: {\r\n            ...(errors[name] && errors[name].types ? errors[name].types : {}),\r\n            [type]: message || true,\r\n        },\r\n    }\r\n    : {};\n\nconst focusFieldBy = (fields, callback, fieldsNames) => {\r\n    for (const key of fieldsNames || Object.keys(fields)) {\r\n        const field = get(fields, key);\r\n        if (field) {\r\n            const { _f, ...currentField } = field;\r\n            if (_f && callback(_f.name)) {\r\n                if (_f.ref.focus) {\r\n                    _f.ref.focus();\r\n                    break;\r\n                }\r\n                else if (_f.refs && _f.refs[0].focus) {\r\n                    _f.refs[0].focus();\r\n                    break;\r\n                }\r\n            }\r\n            else if (isObject(currentField)) {\r\n                focusFieldBy(currentField, callback);\r\n            }\r\n        }\r\n    }\r\n};\n\nvar getValidationModes = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n    isOnAll: mode === VALIDATION_MODE.all,\r\n    isOnTouch: mode === VALIDATION_MODE.onTouched,\r\n});\n\nvar isWatched = (name, _names, isBlurEvent) => !isBlurEvent &&\r\n    (_names.watchAll ||\r\n        _names.watch.has(name) ||\r\n        [..._names.watch].some((watchName) => name.startsWith(watchName) &&\r\n            /^\\.\\w+/.test(name.slice(watchName.length))));\n\nvar updateFieldArrayRootError = (errors, error, name) => {\r\n    const fieldArrayErrors = compact(get(errors, name));\r\n    set(fieldArrayErrors, 'root', error[name]);\r\n    set(errors, name, fieldArrayErrors);\r\n    return errors;\r\n};\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isHTMLElement = (value) => {\r\n    if (!isWeb) {\r\n        return false;\r\n    }\r\n    const owner = value ? value.ownerDocument : 0;\r\n    return (value instanceof\r\n        (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement));\r\n};\n\nvar isMessage = (value) => isString(value);\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nvar isRegex = (value) => value instanceof RegExp;\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (Array.isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.checked && !option.disabled)\r\n                .map((option) => option.value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        return options[0].checked && !options[0].disabled\r\n            ? // @ts-expect-error expected to work in the browser\r\n                options[0].attributes && !isUndefined(options[0].attributes.value)\r\n                    ? isUndefined(options[0].value) || options[0].value === ''\r\n                        ? validResult\r\n                        : { value: options[0].value, isValid: true }\r\n                    : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: null,\r\n};\r\nvar getRadioValue = (options) => Array.isArray(options)\r\n    ? options.reduce((previous, option) => option && option.checked && !option.disabled\r\n        ? {\r\n            isValid: true,\r\n            value: option.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) ||\r\n        (Array.isArray(result) && result.every(isMessage)) ||\r\n        (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData)\r\n    ? validationData\r\n    : {\r\n        value: validationData,\r\n        message: '',\r\n    };\n\nvar validateField = async (field, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) => {\r\n    const { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, valueAsNumber, mount, disabled, } = field._f;\r\n    const inputValue = get(formValues, name);\r\n    if (!mount || disabled) {\r\n        return {};\r\n    }\r\n    const inputRef = refs ? refs[0] : ref;\r\n    const setCustomValidity = (message) => {\r\n        if (shouldUseNativeValidation && inputRef.reportValidity) {\r\n            inputRef.setCustomValidity(isBoolean(message) ? '' : message || '');\r\n            inputRef.reportValidity();\r\n        }\r\n    };\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = ((valueAsNumber || isFileInput(ref)) &&\r\n        isUndefined(ref.value) &&\r\n        isUndefined(inputValue)) ||\r\n        (isHTMLElement(ref) && ref.value === '') ||\r\n        inputValue === '' ||\r\n        (Array.isArray(inputValue) && !inputValue.length);\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = {\r\n            type: exceedMax ? maxType : minType,\r\n            message,\r\n            ref,\r\n            ...appendErrorsCurry(exceedMax ? maxType : minType, message),\r\n        };\r\n    };\r\n    if (isFieldArray\r\n        ? !Array.isArray(inputValue) || !inputValue.length\r\n        : required &&\r\n            ((!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue))) ||\r\n                (isBoolean(inputValue) && !inputValue) ||\r\n                (isCheckBox && !getCheckboxValue(refs).isValid) ||\r\n                (isRadio && !getRadioValue(refs).isValid))) {\r\n        const { value, message } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (value) {\r\n            error[name] = {\r\n                type: INPUT_VALIDATION_RULES.required,\r\n                message,\r\n                ref: inputRef,\r\n                ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message),\r\n            };\r\n            if (!validateAllFieldCriteria) {\r\n                setCustomValidity(message);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const maxOutput = getValueAndMessage(max);\r\n        const minOutput = getValueAndMessage(min);\r\n        if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {\r\n            const valueNumber = ref.valueAsNumber ||\r\n                (inputValue ? +inputValue : inputValue);\r\n            if (!isNullOrUndefined(maxOutput.value)) {\r\n                exceedMax = valueNumber > maxOutput.value;\r\n            }\r\n            if (!isNullOrUndefined(minOutput.value)) {\r\n                exceedMin = valueNumber < minOutput.value;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(inputValue);\r\n            const convertTimeToDate = (time) => new Date(new Date().toDateString() + ' ' + time);\r\n            const isTime = ref.type == 'time';\r\n            const isWeek = ref.type == 'week';\r\n            if (isString(maxOutput.value) && inputValue) {\r\n                exceedMax = isTime\r\n                    ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value)\r\n                    : isWeek\r\n                        ? inputValue > maxOutput.value\r\n                        : valueDate > new Date(maxOutput.value);\r\n            }\r\n            if (isString(minOutput.value) && inputValue) {\r\n                exceedMin = isTime\r\n                    ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value)\r\n                    : isWeek\r\n                        ? inputValue < minOutput.value\r\n                        : valueDate < new Date(minOutput.value);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                setCustomValidity(error[name].message);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if ((maxLength || minLength) &&\r\n        !isEmpty &&\r\n        (isString(inputValue) || (isFieldArray && Array.isArray(inputValue)))) {\r\n        const maxLengthOutput = getValueAndMessage(maxLength);\r\n        const minLengthOutput = getValueAndMessage(minLength);\r\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) &&\r\n            inputValue.length > maxLengthOutput.value;\r\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) &&\r\n            inputValue.length < minLengthOutput.value;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\r\n            if (!validateAllFieldCriteria) {\r\n                setCustomValidity(error[name].message);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (pattern && !isEmpty && isString(inputValue)) {\r\n        const { value: patternValue, message } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !inputValue.match(patternValue)) {\r\n            error[name] = {\r\n                type: INPUT_VALIDATION_RULES.pattern,\r\n                message,\r\n                ref,\r\n                ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message),\r\n            };\r\n            if (!validateAllFieldCriteria) {\r\n                setCustomValidity(message);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        if (isFunction(validate)) {\r\n            const result = await validate(inputValue, formValues);\r\n            const validateError = getValidateError(result, inputRef);\r\n            if (validateError) {\r\n                error[name] = {\r\n                    ...validateError,\r\n                    ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message),\r\n                };\r\n                if (!validateAllFieldCriteria) {\r\n                    setCustomValidity(validateError.message);\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const key in validate) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);\r\n                if (validateError) {\r\n                    validationResult = {\r\n                        ...validateError,\r\n                        ...appendErrorsCurry(key, validateError.message),\r\n                    };\r\n                    setCustomValidity(validateError.message);\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = {\r\n                    ref: inputRef,\r\n                    ...validationResult,\r\n                };\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    setCustomValidity(true);\r\n    return error;\r\n};\n\nfunction baseGet(object, updatePath) {\r\n    const length = updatePath.slice(0, -1).length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return object;\r\n}\r\nfunction isEmptyArray(obj) {\r\n    for (const key in obj) {\r\n        if (!isUndefined(obj[key])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction unset(object, path) {\r\n    const paths = Array.isArray(path)\r\n        ? path\r\n        : isKey(path)\r\n            ? [path]\r\n            : stringToPath(path);\r\n    const childObject = paths.length === 1 ? object : baseGet(object, paths);\r\n    const index = paths.length - 1;\r\n    const key = paths[index];\r\n    if (childObject) {\r\n        delete childObject[key];\r\n    }\r\n    if (index !== 0 &&\r\n        ((isObject(childObject) && isEmptyObject(childObject)) ||\r\n            (Array.isArray(childObject) && isEmptyArray(childObject)))) {\r\n        unset(object, paths.slice(0, -1));\r\n    }\r\n    return object;\r\n}\n\nfunction createSubject() {\r\n    let _observers = [];\r\n    const next = (value) => {\r\n        for (const observer of _observers) {\r\n            observer.next && observer.next(value);\r\n        }\r\n    };\r\n    const subscribe = (observer) => {\r\n        _observers.push(observer);\r\n        return {\r\n            unsubscribe: () => {\r\n                _observers = _observers.filter((o) => o !== observer);\r\n            },\r\n        };\r\n    };\r\n    const unsubscribe = () => {\r\n        _observers = [];\r\n    };\r\n    return {\r\n        get observers() {\r\n            return _observers;\r\n        },\r\n        next,\r\n        subscribe,\r\n        unsubscribe,\r\n    };\r\n}\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepEqual(object1, object2) {\r\n    if (isPrimitive(object1) || isPrimitive(object2)) {\r\n        return object1 === object2;\r\n    }\r\n    if (isDateObject(object1) && isDateObject(object2)) {\r\n        return object1.getTime() === object2.getTime();\r\n    }\r\n    const keys1 = Object.keys(object1);\r\n    const keys2 = Object.keys(object2);\r\n    if (keys1.length !== keys2.length) {\r\n        return false;\r\n    }\r\n    for (const key of keys1) {\r\n        const val1 = object1[key];\r\n        if (!keys2.includes(key)) {\r\n            return false;\r\n        }\r\n        if (key !== 'ref') {\r\n            const val2 = object2[key];\r\n            if ((isDateObject(val1) && isDateObject(val2)) ||\r\n                (isObject(val1) && isObject(val2)) ||\r\n                (Array.isArray(val1) && Array.isArray(val2))\r\n                ? !deepEqual(val1, val2)\r\n                : val1 !== val2) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\n\nvar isMultipleSelect = (element) => element.type === `select-multiple`;\n\nvar isRadioOrCheckbox = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nvar live = (ref) => isHTMLElement(ref) && ref.isConnected;\n\nvar objectHasFunction = (data) => {\r\n    for (const key in data) {\r\n        if (isFunction(data[key])) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\n\nfunction markFieldsDirty(data, fields = {}) {\r\n    const isParentNodeArray = Array.isArray(data);\r\n    if (isObject(data) || isParentNodeArray) {\r\n        for (const key in data) {\r\n            if (Array.isArray(data[key]) ||\r\n                (isObject(data[key]) && !objectHasFunction(data[key]))) {\r\n                fields[key] = Array.isArray(data[key]) ? [] : {};\r\n                markFieldsDirty(data[key], fields[key]);\r\n            }\r\n            else if (!isNullOrUndefined(data[key])) {\r\n                fields[key] = true;\r\n            }\r\n        }\r\n    }\r\n    return fields;\r\n}\r\nfunction getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {\r\n    const isParentNodeArray = Array.isArray(data);\r\n    if (isObject(data) || isParentNodeArray) {\r\n        for (const key in data) {\r\n            if (Array.isArray(data[key]) ||\r\n                (isObject(data[key]) && !objectHasFunction(data[key]))) {\r\n                if (isUndefined(formValues) ||\r\n                    isPrimitive(dirtyFieldsFromValues[key])) {\r\n                    dirtyFieldsFromValues[key] = Array.isArray(data[key])\r\n                        ? markFieldsDirty(data[key], [])\r\n                        : { ...markFieldsDirty(data[key]) };\r\n                }\r\n                else {\r\n                    getDirtyFieldsFromDefaultValues(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);\r\n                }\r\n            }\r\n            else {\r\n                dirtyFieldsFromValues[key] = !deepEqual(data[key], formValues[key]);\r\n            }\r\n        }\r\n    }\r\n    return dirtyFieldsFromValues;\r\n}\r\nvar getDirtyFields = (defaultValues, formValues) => getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));\n\nvar getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value)\r\n    ? value\r\n    : valueAsNumber\r\n        ? value === ''\r\n            ? NaN\r\n            : value\r\n                ? +value\r\n                : value\r\n        : valueAsDate && isString(value)\r\n            ? new Date(value)\r\n            : setValueAs\r\n                ? setValueAs(value)\r\n                : value;\n\nfunction getFieldValue(_f) {\r\n    const ref = _f.ref;\r\n    if (_f.refs ? _f.refs.every((ref) => ref.disabled) : ref.disabled) {\r\n        return;\r\n    }\r\n    if (isFileInput(ref)) {\r\n        return ref.files;\r\n    }\r\n    if (isRadioInput(ref)) {\r\n        return getRadioValue(_f.refs).value;\r\n    }\r\n    if (isMultipleSelect(ref)) {\r\n        return [...ref.selectedOptions].map(({ value }) => value);\r\n    }\r\n    if (isCheckBoxInput(ref)) {\r\n        return getCheckboxValue(_f.refs).value;\r\n    }\r\n    return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);\r\n}\n\nvar getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {\r\n    const fields = {};\r\n    for (const name of fieldsNames) {\r\n        const field = get(_fields, name);\r\n        field && set(fields, name, field._f);\r\n    }\r\n    return {\r\n        criteriaMode,\r\n        names: [...fieldsNames],\r\n        fields,\r\n        shouldUseNativeValidation,\r\n    };\r\n};\n\nvar getRuleValue = (rule) => isUndefined(rule)\r\n    ? rule\r\n    : isRegex(rule)\r\n        ? rule.source\r\n        : isObject(rule)\r\n            ? isRegex(rule.value)\r\n                ? rule.value.source\r\n                : rule.value\r\n            : rule;\n\nvar hasValidation = (options) => options.mount &&\r\n    (options.required ||\r\n        options.min ||\r\n        options.max ||\r\n        options.maxLength ||\r\n        options.minLength ||\r\n        options.pattern ||\r\n        options.validate);\n\nfunction schemaErrorLookup(errors, _fields, name) {\r\n    const error = get(errors, name);\r\n    if (error || isKey(name)) {\r\n        return {\r\n            error,\r\n            name,\r\n        };\r\n    }\r\n    const names = name.split('.');\r\n    while (names.length) {\r\n        const fieldName = names.join('.');\r\n        const field = get(_fields, fieldName);\r\n        const foundError = get(errors, fieldName);\r\n        if (field && !Array.isArray(field) && name !== fieldName) {\r\n            return { name };\r\n        }\r\n        if (foundError && foundError.type) {\r\n            return {\r\n                name: fieldName,\r\n                error: foundError,\r\n            };\r\n        }\r\n        names.pop();\r\n    }\r\n    return {\r\n        name,\r\n    };\r\n}\n\nvar skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {\r\n    if (mode.isOnAll) {\r\n        return false;\r\n    }\r\n    else if (!isSubmitted && mode.isOnTouch) {\r\n        return !(isTouched || isBlurEvent);\r\n    }\r\n    else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {\r\n        return !isBlurEvent;\r\n    }\r\n    else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {\r\n        return isBlurEvent;\r\n    }\r\n    return true;\r\n};\n\nvar unsetEmptyArray = (ref, name) => !compact(get(ref, name)).length && unset(ref, name);\n\nconst defaultOptions = {\r\n    mode: VALIDATION_MODE.onSubmit,\r\n    reValidateMode: VALIDATION_MODE.onChange,\r\n    shouldFocusError: true,\r\n};\r\nfunction createFormControl(props = {}, flushRootRender) {\r\n    let _options = {\r\n        ...defaultOptions,\r\n        ...props,\r\n    };\r\n    let _formState = {\r\n        submitCount: 0,\r\n        isDirty: false,\r\n        isLoading: true,\r\n        isValidating: false,\r\n        isSubmitted: false,\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: false,\r\n        touchedFields: {},\r\n        dirtyFields: {},\r\n        errors: {},\r\n    };\r\n    let _fields = {};\r\n    let _defaultValues = isObject(_options.defaultValues) || isObject(_options.values)\r\n        ? cloneObject(_options.defaultValues || _options.values) || {}\r\n        : {};\r\n    let _formValues = _options.shouldUnregister\r\n        ? {}\r\n        : cloneObject(_defaultValues);\r\n    let _state = {\r\n        action: false,\r\n        mount: false,\r\n        watch: false,\r\n    };\r\n    let _names = {\r\n        mount: new Set(),\r\n        unMount: new Set(),\r\n        array: new Set(),\r\n        watch: new Set(),\r\n    };\r\n    let delayErrorCallback;\r\n    let timer = 0;\r\n    const _proxyFormState = {\r\n        isDirty: false,\r\n        dirtyFields: false,\r\n        touchedFields: false,\r\n        isValidating: false,\r\n        isValid: false,\r\n        errors: false,\r\n    };\r\n    const _subjects = {\r\n        values: createSubject(),\r\n        array: createSubject(),\r\n        state: createSubject(),\r\n    };\r\n    const shouldCaptureDirtyFields = props.resetOptions && props.resetOptions.keepDirtyValues;\r\n    const validationModeBeforeSubmit = getValidationModes(_options.mode);\r\n    const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);\r\n    const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;\r\n    const debounce = (callback) => (wait) => {\r\n        clearTimeout(timer);\r\n        timer = setTimeout(callback, wait);\r\n    };\r\n    const _updateValid = async (shouldUpdateValid) => {\r\n        if (_proxyFormState.isValid || shouldUpdateValid) {\r\n            const isValid = _options.resolver\r\n                ? isEmptyObject((await _executeSchema()).errors)\r\n                : await executeBuiltInValidation(_fields, true);\r\n            if (isValid !== _formState.isValid) {\r\n                _subjects.state.next({\r\n                    isValid,\r\n                });\r\n            }\r\n        }\r\n    };\r\n    const _updateIsValidating = (value) => _proxyFormState.isValidating &&\r\n        _subjects.state.next({\r\n            isValidating: value,\r\n        });\r\n    const _updateFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true) => {\r\n        if (args && method) {\r\n            _state.action = true;\r\n            if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {\r\n                const fieldValues = method(get(_fields, name), args.argA, args.argB);\r\n                shouldSetValues && set(_fields, name, fieldValues);\r\n            }\r\n            if (shouldUpdateFieldsAndState &&\r\n                Array.isArray(get(_formState.errors, name))) {\r\n                const errors = method(get(_formState.errors, name), args.argA, args.argB);\r\n                shouldSetValues && set(_formState.errors, name, errors);\r\n                unsetEmptyArray(_formState.errors, name);\r\n            }\r\n            if (_proxyFormState.touchedFields &&\r\n                shouldUpdateFieldsAndState &&\r\n                Array.isArray(get(_formState.touchedFields, name))) {\r\n                const touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);\r\n                shouldSetValues && set(_formState.touchedFields, name, touchedFields);\r\n            }\r\n            if (_proxyFormState.dirtyFields) {\r\n                _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);\r\n            }\r\n            _subjects.state.next({\r\n                name,\r\n                isDirty: _getDirty(name, values),\r\n                dirtyFields: _formState.dirtyFields,\r\n                errors: _formState.errors,\r\n                isValid: _formState.isValid,\r\n            });\r\n        }\r\n        else {\r\n            set(_formValues, name, values);\r\n        }\r\n    };\r\n    const updateErrors = (name, error) => {\r\n        set(_formState.errors, name, error);\r\n        _subjects.state.next({\r\n            errors: _formState.errors,\r\n        });\r\n    };\r\n    const updateValidAndValue = (name, shouldSkipSetValueAs, value, ref) => {\r\n        const field = get(_fields, name);\r\n        if (field) {\r\n            const defaultValue = get(_formValues, name, isUndefined(value) ? get(_defaultValues, name) : value);\r\n            isUndefined(defaultValue) ||\r\n                (ref && ref.defaultChecked) ||\r\n                shouldSkipSetValueAs\r\n                ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f))\r\n                : setFieldValue(name, defaultValue);\r\n            _state.mount && _updateValid();\r\n        }\r\n    };\r\n    const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {\r\n        let shouldUpdateField = false;\r\n        let isPreviousDirty = false;\r\n        const output = {\r\n            name,\r\n        };\r\n        if (!isBlurEvent || shouldDirty) {\r\n            if (_proxyFormState.isDirty) {\r\n                isPreviousDirty = _formState.isDirty;\r\n                _formState.isDirty = output.isDirty = _getDirty();\r\n                shouldUpdateField = isPreviousDirty !== output.isDirty;\r\n            }\r\n            const isCurrentFieldPristine = deepEqual(get(_defaultValues, name), fieldValue);\r\n            isPreviousDirty = get(_formState.dirtyFields, name);\r\n            isCurrentFieldPristine\r\n                ? unset(_formState.dirtyFields, name)\r\n                : set(_formState.dirtyFields, name, true);\r\n            output.dirtyFields = _formState.dirtyFields;\r\n            shouldUpdateField =\r\n                shouldUpdateField ||\r\n                    (_proxyFormState.dirtyFields &&\r\n                        isPreviousDirty !== !isCurrentFieldPristine);\r\n        }\r\n        if (isBlurEvent) {\r\n            const isPreviousFieldTouched = get(_formState.touchedFields, name);\r\n            if (!isPreviousFieldTouched) {\r\n                set(_formState.touchedFields, name, isBlurEvent);\r\n                output.touchedFields = _formState.touchedFields;\r\n                shouldUpdateField =\r\n                    shouldUpdateField ||\r\n                        (_proxyFormState.touchedFields &&\r\n                            isPreviousFieldTouched !== isBlurEvent);\r\n            }\r\n        }\r\n        shouldUpdateField && shouldRender && _subjects.state.next(output);\r\n        return shouldUpdateField ? output : {};\r\n    };\r\n    const shouldRenderByError = (name, isValid, error, fieldState) => {\r\n        const previousFieldError = get(_formState.errors, name);\r\n        const shouldUpdateValid = _proxyFormState.isValid &&\r\n            isBoolean(isValid) &&\r\n            _formState.isValid !== isValid;\r\n        if (props.delayError && error) {\r\n            delayErrorCallback = debounce(() => updateErrors(name, error));\r\n            delayErrorCallback(props.delayError);\r\n        }\r\n        else {\r\n            clearTimeout(timer);\r\n            delayErrorCallback = null;\r\n            error\r\n                ? set(_formState.errors, name, error)\r\n                : unset(_formState.errors, name);\r\n        }\r\n        if ((error ? !deepEqual(previousFieldError, error) : previousFieldError) ||\r\n            !isEmptyObject(fieldState) ||\r\n            shouldUpdateValid) {\r\n            const updatedFormState = {\r\n                ...fieldState,\r\n                ...(shouldUpdateValid && isBoolean(isValid) ? { isValid } : {}),\r\n                errors: _formState.errors,\r\n                name,\r\n            };\r\n            _formState = {\r\n                ..._formState,\r\n                ...updatedFormState,\r\n            };\r\n            _subjects.state.next(updatedFormState);\r\n        }\r\n        _updateIsValidating(false);\r\n    };\r\n    const _executeSchema = async (name) => _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));\r\n    const executeSchemaAndUpdateState = async (names) => {\r\n        const { errors } = await _executeSchema();\r\n        if (names) {\r\n            for (const name of names) {\r\n                const error = get(errors, name);\r\n                error\r\n                    ? set(_formState.errors, name, error)\r\n                    : unset(_formState.errors, name);\r\n            }\r\n        }\r\n        else {\r\n            _formState.errors = errors;\r\n        }\r\n        return errors;\r\n    };\r\n    const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {\r\n        valid: true,\r\n    }) => {\r\n        for (const name in fields) {\r\n            const field = fields[name];\r\n            if (field) {\r\n                const { _f, ...fieldValue } = field;\r\n                if (_f) {\r\n                    const isFieldArrayRoot = _names.array.has(_f.name);\r\n                    const fieldError = await validateField(field, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation, isFieldArrayRoot);\r\n                    if (fieldError[_f.name]) {\r\n                        context.valid = false;\r\n                        if (shouldOnlyCheckValid) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    !shouldOnlyCheckValid &&\r\n                        (get(fieldError, _f.name)\r\n                            ? isFieldArrayRoot\r\n                                ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name)\r\n                                : set(_formState.errors, _f.name, fieldError[_f.name])\r\n                            : unset(_formState.errors, _f.name));\r\n                }\r\n                fieldValue &&\r\n                    (await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context));\r\n            }\r\n        }\r\n        return context.valid;\r\n    };\r\n    const _removeUnmounted = () => {\r\n        for (const name of _names.unMount) {\r\n            const field = get(_fields, name);\r\n            field &&\r\n                (field._f.refs\r\n                    ? field._f.refs.every((ref) => !live(ref))\r\n                    : !live(field._f.ref)) &&\r\n                unregister(name);\r\n        }\r\n        _names.unMount = new Set();\r\n    };\r\n    const _getDirty = (name, data) => (name && data && set(_formValues, name, data),\r\n        !deepEqual(getValues(), _defaultValues));\r\n    const _getWatch = (names, defaultValue, isGlobal) => generateWatchOutput(names, _names, {\r\n        ...(_state.mount\r\n            ? _formValues\r\n            : isUndefined(defaultValue)\r\n                ? _defaultValues\r\n                : isString(names)\r\n                    ? { [names]: defaultValue }\r\n                    : defaultValue),\r\n    }, isGlobal, defaultValue);\r\n    const _getFieldArray = (name) => compact(get(_state.mount ? _formValues : _defaultValues, name, props.shouldUnregister ? get(_defaultValues, name, []) : []));\r\n    const setFieldValue = (name, value, options = {}) => {\r\n        const field = get(_fields, name);\r\n        let fieldValue = value;\r\n        if (field) {\r\n            const fieldReference = field._f;\r\n            if (fieldReference) {\r\n                !fieldReference.disabled &&\r\n                    set(_formValues, name, getFieldValueAs(value, fieldReference));\r\n                fieldValue =\r\n                    isHTMLElement(fieldReference.ref) && isNullOrUndefined(value)\r\n                        ? ''\r\n                        : value;\r\n                if (isMultipleSelect(fieldReference.ref)) {\r\n                    [...fieldReference.ref.options].forEach((optionRef) => (optionRef.selected = fieldValue.includes(optionRef.value)));\r\n                }\r\n                else if (fieldReference.refs) {\r\n                    if (isCheckBoxInput(fieldReference.ref)) {\r\n                        fieldReference.refs.length > 1\r\n                            ? fieldReference.refs.forEach((checkboxRef) => (!checkboxRef.defaultChecked || !checkboxRef.disabled) &&\r\n                                (checkboxRef.checked = Array.isArray(fieldValue)\r\n                                    ? !!fieldValue.find((data) => data === checkboxRef.value)\r\n                                    : fieldValue === checkboxRef.value))\r\n                            : fieldReference.refs[0] &&\r\n                                (fieldReference.refs[0].checked = !!fieldValue);\r\n                    }\r\n                    else {\r\n                        fieldReference.refs.forEach((radioRef) => (radioRef.checked = radioRef.value === fieldValue));\r\n                    }\r\n                }\r\n                else if (isFileInput(fieldReference.ref)) {\r\n                    fieldReference.ref.value = '';\r\n                }\r\n                else {\r\n                    fieldReference.ref.value = fieldValue;\r\n                    if (!fieldReference.ref.type) {\r\n                        _subjects.values.next({\r\n                            name,\r\n                            values: { ..._formValues },\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        (options.shouldDirty || options.shouldTouch) &&\r\n            updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);\r\n        options.shouldValidate && trigger(name);\r\n    };\r\n    const setValues = (name, value, options) => {\r\n        for (const fieldKey in value) {\r\n            const fieldValue = value[fieldKey];\r\n            const fieldName = `${name}.${fieldKey}`;\r\n            const field = get(_fields, fieldName);\r\n            (_names.array.has(name) ||\r\n                !isPrimitive(fieldValue) ||\r\n                (field && !field._f)) &&\r\n                !isDateObject(fieldValue)\r\n                ? setValues(fieldName, fieldValue, options)\r\n                : setFieldValue(fieldName, fieldValue, options);\r\n        }\r\n    };\r\n    const setValue = (name, value, options = {}) => {\r\n        const field = get(_fields, name);\r\n        const isFieldArray = _names.array.has(name);\r\n        const cloneValue = cloneObject(value);\r\n        set(_formValues, name, cloneValue);\r\n        if (isFieldArray) {\r\n            _subjects.array.next({\r\n                name,\r\n                values: { ..._formValues },\r\n            });\r\n            if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields) &&\r\n                options.shouldDirty) {\r\n                _subjects.state.next({\r\n                    name,\r\n                    dirtyFields: getDirtyFields(_defaultValues, _formValues),\r\n                    isDirty: _getDirty(name, cloneValue),\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            field && !field._f && !isNullOrUndefined(cloneValue)\r\n                ? setValues(name, cloneValue, options)\r\n                : setFieldValue(name, cloneValue, options);\r\n        }\r\n        isWatched(name, _names) && _subjects.state.next({ ..._formState });\r\n        _subjects.values.next({\r\n            name,\r\n            values: { ..._formValues },\r\n        });\r\n        !_state.mount && flushRootRender();\r\n    };\r\n    const onChange = async (event) => {\r\n        const target = event.target;\r\n        let name = target.name;\r\n        const field = get(_fields, name);\r\n        const getCurrentFieldValue = () => target.type ? getFieldValue(field._f) : getEventValue(event);\r\n        if (field) {\r\n            let error;\r\n            let isValid;\r\n            const fieldValue = getCurrentFieldValue();\r\n            const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;\r\n            const shouldSkipValidation = (!hasValidation(field._f) &&\r\n                !_options.resolver &&\r\n                !get(_formState.errors, name) &&\r\n                !field._f.deps) ||\r\n                skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);\r\n            const watched = isWatched(name, _names, isBlurEvent);\r\n            set(_formValues, name, fieldValue);\r\n            if (isBlurEvent) {\r\n                field._f.onBlur && field._f.onBlur(event);\r\n                delayErrorCallback && delayErrorCallback(0);\r\n            }\r\n            else if (field._f.onChange) {\r\n                field._f.onChange(event);\r\n            }\r\n            const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent, false);\r\n            const shouldRender = !isEmptyObject(fieldState) || watched;\r\n            !isBlurEvent &&\r\n                _subjects.values.next({\r\n                    name,\r\n                    type: event.type,\r\n                    values: { ..._formValues },\r\n                });\r\n            if (shouldSkipValidation) {\r\n                _proxyFormState.isValid && _updateValid();\r\n                return (shouldRender &&\r\n                    _subjects.state.next({ name, ...(watched ? {} : fieldState) }));\r\n            }\r\n            !isBlurEvent && watched && _subjects.state.next({ ..._formState });\r\n            _updateIsValidating(true);\r\n            if (_options.resolver) {\r\n                const { errors } = await _executeSchema([name]);\r\n                const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);\r\n                const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);\r\n                error = errorLookupResult.error;\r\n                name = errorLookupResult.name;\r\n                isValid = isEmptyObject(errors);\r\n            }\r\n            else {\r\n                error = (await validateField(field, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];\r\n                if (error) {\r\n                    isValid = false;\r\n                }\r\n                else if (_proxyFormState.isValid) {\r\n                    isValid = await executeBuiltInValidation(_fields, true);\r\n                }\r\n            }\r\n            field._f.deps &&\r\n                trigger(field._f.deps);\r\n            shouldRenderByError(name, isValid, error, fieldState);\r\n        }\r\n    };\r\n    const trigger = async (name, options = {}) => {\r\n        let isValid;\r\n        let validationResult;\r\n        const fieldNames = convertToArrayPayload(name);\r\n        _updateIsValidating(true);\r\n        if (_options.resolver) {\r\n            const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);\r\n            isValid = isEmptyObject(errors);\r\n            validationResult = name\r\n                ? !fieldNames.some((name) => get(errors, name))\r\n                : isValid;\r\n        }\r\n        else if (name) {\r\n            validationResult = (await Promise.all(fieldNames.map(async (fieldName) => {\r\n                const field = get(_fields, fieldName);\r\n                return await executeBuiltInValidation(field && field._f ? { [fieldName]: field } : field);\r\n            }))).every(Boolean);\r\n            !(!validationResult && !_formState.isValid) && _updateValid();\r\n        }\r\n        else {\r\n            validationResult = isValid = await executeBuiltInValidation(_fields);\r\n        }\r\n        _subjects.state.next({\r\n            ...(!isString(name) ||\r\n                (_proxyFormState.isValid && isValid !== _formState.isValid)\r\n                ? {}\r\n                : { name }),\r\n            ...(_options.resolver || !name ? { isValid } : {}),\r\n            errors: _formState.errors,\r\n            isValidating: false,\r\n        });\r\n        options.shouldFocus &&\r\n            !validationResult &&\r\n            focusFieldBy(_fields, (key) => key && get(_formState.errors, key), name ? fieldNames : _names.mount);\r\n        return validationResult;\r\n    };\r\n    const getValues = (fieldNames) => {\r\n        const values = {\r\n            ..._defaultValues,\r\n            ...(_state.mount ? _formValues : {}),\r\n        };\r\n        return isUndefined(fieldNames)\r\n            ? values\r\n            : isString(fieldNames)\r\n                ? get(values, fieldNames)\r\n                : fieldNames.map((name) => get(values, name));\r\n    };\r\n    const getFieldState = (name, formState) => ({\r\n        invalid: !!get((formState || _formState).errors, name),\r\n        isDirty: !!get((formState || _formState).dirtyFields, name),\r\n        isTouched: !!get((formState || _formState).touchedFields, name),\r\n        error: get((formState || _formState).errors, name),\r\n    });\r\n    const clearErrors = (name) => {\r\n        name &&\r\n            convertToArrayPayload(name).forEach((inputName) => unset(_formState.errors, inputName));\r\n        _subjects.state.next({\r\n            errors: name ? _formState.errors : {},\r\n        });\r\n    };\r\n    const setError = (name, error, options) => {\r\n        const ref = (get(_fields, name, { _f: {} })._f || {}).ref;\r\n        set(_formState.errors, name, {\r\n            ...error,\r\n            ref,\r\n        });\r\n        _subjects.state.next({\r\n            name,\r\n            errors: _formState.errors,\r\n            isValid: false,\r\n        });\r\n        options && options.shouldFocus && ref && ref.focus && ref.focus();\r\n    };\r\n    const watch = (name, defaultValue) => isFunction(name)\r\n        ? _subjects.values.subscribe({\r\n            next: (payload) => name(_getWatch(undefined, defaultValue), payload),\r\n        })\r\n        : _getWatch(name, defaultValue, true);\r\n    const unregister = (name, options = {}) => {\r\n        for (const fieldName of name ? convertToArrayPayload(name) : _names.mount) {\r\n            _names.mount.delete(fieldName);\r\n            _names.array.delete(fieldName);\r\n            if (get(_fields, fieldName)) {\r\n                if (!options.keepValue) {\r\n                    unset(_fields, fieldName);\r\n                    unset(_formValues, fieldName);\r\n                }\r\n                !options.keepError && unset(_formState.errors, fieldName);\r\n                !options.keepDirty && unset(_formState.dirtyFields, fieldName);\r\n                !options.keepTouched && unset(_formState.touchedFields, fieldName);\r\n                !_options.shouldUnregister &&\r\n                    !options.keepDefaultValue &&\r\n                    unset(_defaultValues, fieldName);\r\n            }\r\n        }\r\n        _subjects.values.next({\r\n            values: { ..._formValues },\r\n        });\r\n        _subjects.state.next({\r\n            ..._formState,\r\n            ...(!options.keepDirty ? {} : { isDirty: _getDirty() }),\r\n        });\r\n        !options.keepIsValid && _updateValid();\r\n    };\r\n    const register = (name, options = {}) => {\r\n        let field = get(_fields, name);\r\n        const disabledIsDefined = isBoolean(options.disabled);\r\n        set(_fields, name, {\r\n            ...(field || {}),\r\n            _f: {\r\n                ...(field && field._f ? field._f : { ref: { name } }),\r\n                name,\r\n                mount: true,\r\n                ...options,\r\n            },\r\n        });\r\n        _names.mount.add(name);\r\n        field\r\n            ? disabledIsDefined &&\r\n                set(_formValues, name, options.disabled\r\n                    ? undefined\r\n                    : get(_formValues, name, getFieldValue(field._f)))\r\n            : updateValidAndValue(name, true, options.value);\r\n        return {\r\n            ...(disabledIsDefined ? { disabled: options.disabled } : {}),\r\n            ...(_options.shouldUseNativeValidation\r\n                ? {\r\n                    required: !!options.required,\r\n                    min: getRuleValue(options.min),\r\n                    max: getRuleValue(options.max),\r\n                    minLength: getRuleValue(options.minLength),\r\n                    maxLength: getRuleValue(options.maxLength),\r\n                    pattern: getRuleValue(options.pattern),\r\n                }\r\n                : {}),\r\n            name,\r\n            onChange,\r\n            onBlur: onChange,\r\n            ref: (ref) => {\r\n                if (ref) {\r\n                    register(name, options);\r\n                    field = get(_fields, name);\r\n                    const fieldRef = isUndefined(ref.value)\r\n                        ? ref.querySelectorAll\r\n                            ? ref.querySelectorAll('input,select,textarea')[0] || ref\r\n                            : ref\r\n                        : ref;\r\n                    const radioOrCheckbox = isRadioOrCheckbox(fieldRef);\r\n                    const refs = field._f.refs || [];\r\n                    if (radioOrCheckbox\r\n                        ? refs.find((option) => option === fieldRef)\r\n                        : fieldRef === field._f.ref) {\r\n                        return;\r\n                    }\r\n                    set(_fields, name, {\r\n                        _f: {\r\n                            ...field._f,\r\n                            ...(radioOrCheckbox\r\n                                ? {\r\n                                    refs: [\r\n                                        ...refs.filter(live),\r\n                                        fieldRef,\r\n                                        ...(Array.isArray(get(_defaultValues, name)) ? [{}] : []),\r\n                                    ],\r\n                                    ref: { type: fieldRef.type, name },\r\n                                }\r\n                                : { ref: fieldRef }),\r\n                        },\r\n                    });\r\n                    updateValidAndValue(name, false, undefined, fieldRef);\r\n                }\r\n                else {\r\n                    field = get(_fields, name, {});\r\n                    if (field._f) {\r\n                        field._f.mount = false;\r\n                    }\r\n                    (_options.shouldUnregister || options.shouldUnregister) &&\r\n                        !(isNameInFieldArray(_names.array, name) && _state.action) &&\r\n                        _names.unMount.add(name);\r\n                }\r\n            },\r\n        };\r\n    };\r\n    const _focusError = () => _options.shouldFocusError &&\r\n        focusFieldBy(_fields, (key) => key && get(_formState.errors, key), _names.mount);\r\n    const handleSubmit = (onValid, onInvalid) => async (e) => {\r\n        if (e) {\r\n            e.preventDefault && e.preventDefault();\r\n            e.persist && e.persist();\r\n        }\r\n        let fieldValues = cloneObject(_formValues);\r\n        _subjects.state.next({\r\n            isSubmitting: true,\r\n        });\r\n        if (_options.resolver) {\r\n            const { errors, values } = await _executeSchema();\r\n            _formState.errors = errors;\r\n            fieldValues = values;\r\n        }\r\n        else {\r\n            await executeBuiltInValidation(_fields);\r\n        }\r\n        unset(_formState.errors, 'root');\r\n        if (isEmptyObject(_formState.errors)) {\r\n            _subjects.state.next({\r\n                errors: {},\r\n            });\r\n            await onValid(fieldValues, e);\r\n        }\r\n        else {\r\n            if (onInvalid) {\r\n                await onInvalid({ ..._formState.errors }, e);\r\n            }\r\n            _focusError();\r\n            setTimeout(_focusError);\r\n        }\r\n        _subjects.state.next({\r\n            isSubmitted: true,\r\n            isSubmitting: false,\r\n            isSubmitSuccessful: isEmptyObject(_formState.errors),\r\n            submitCount: _formState.submitCount + 1,\r\n            errors: _formState.errors,\r\n        });\r\n    };\r\n    const resetField = (name, options = {}) => {\r\n        if (get(_fields, name)) {\r\n            if (isUndefined(options.defaultValue)) {\r\n                setValue(name, get(_defaultValues, name));\r\n            }\r\n            else {\r\n                setValue(name, options.defaultValue);\r\n                set(_defaultValues, name, options.defaultValue);\r\n            }\r\n            if (!options.keepTouched) {\r\n                unset(_formState.touchedFields, name);\r\n            }\r\n            if (!options.keepDirty) {\r\n                unset(_formState.dirtyFields, name);\r\n                _formState.isDirty = options.defaultValue\r\n                    ? _getDirty(name, get(_defaultValues, name))\r\n                    : _getDirty();\r\n            }\r\n            if (!options.keepError) {\r\n                unset(_formState.errors, name);\r\n                _proxyFormState.isValid && _updateValid();\r\n            }\r\n            _subjects.state.next({ ..._formState });\r\n        }\r\n    };\r\n    const _reset = (formValues, keepStateOptions = {}) => {\r\n        const updatedValues = formValues || _defaultValues;\r\n        const cloneUpdatedValues = cloneObject(updatedValues);\r\n        const values = formValues && !isEmptyObject(formValues)\r\n            ? cloneUpdatedValues\r\n            : _defaultValues;\r\n        if (!keepStateOptions.keepDefaultValues) {\r\n            _defaultValues = updatedValues;\r\n        }\r\n        if (!keepStateOptions.keepValues) {\r\n            if (keepStateOptions.keepDirtyValues || shouldCaptureDirtyFields) {\r\n                for (const fieldName of _names.mount) {\r\n                    get(_formState.dirtyFields, fieldName)\r\n                        ? set(values, fieldName, get(_formValues, fieldName))\r\n                        : setValue(fieldName, get(values, fieldName));\r\n                }\r\n            }\r\n            else {\r\n                if (isWeb && isUndefined(formValues)) {\r\n                    for (const name of _names.mount) {\r\n                        const field = get(_fields, name);\r\n                        if (field && field._f) {\r\n                            const fieldReference = Array.isArray(field._f.refs)\r\n                                ? field._f.refs[0]\r\n                                : field._f.ref;\r\n                            if (isHTMLElement(fieldReference)) {\r\n                                const form = fieldReference.closest('form');\r\n                                if (form) {\r\n                                    form.reset();\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                _fields = {};\r\n            }\r\n            _formValues = props.shouldUnregister\r\n                ? keepStateOptions.keepDefaultValues\r\n                    ? cloneObject(_defaultValues)\r\n                    : {}\r\n                : cloneUpdatedValues;\r\n            _subjects.array.next({\r\n                values: { ...values },\r\n            });\r\n            _subjects.values.next({\r\n                values: { ...values },\r\n            });\r\n        }\r\n        _names = {\r\n            mount: new Set(),\r\n            unMount: new Set(),\r\n            array: new Set(),\r\n            watch: new Set(),\r\n            watchAll: false,\r\n            focus: '',\r\n        };\r\n        !_state.mount && flushRootRender();\r\n        _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid;\r\n        _state.watch = !!props.shouldUnregister;\r\n        _subjects.state.next({\r\n            submitCount: keepStateOptions.keepSubmitCount\r\n                ? _formState.submitCount\r\n                : 0,\r\n            isDirty: keepStateOptions.keepDirty\r\n                ? _formState.isDirty\r\n                : !!(keepStateOptions.keepDefaultValues &&\r\n                    !deepEqual(formValues, _defaultValues)),\r\n            isSubmitted: keepStateOptions.keepIsSubmitted\r\n                ? _formState.isSubmitted\r\n                : false,\r\n            dirtyFields: keepStateOptions.keepDirtyValues\r\n                ? _formState.dirtyFields\r\n                : keepStateOptions.keepDefaultValues && formValues\r\n                    ? getDirtyFields(_defaultValues, formValues)\r\n                    : {},\r\n            touchedFields: keepStateOptions.keepTouched\r\n                ? _formState.touchedFields\r\n                : {},\r\n            errors: keepStateOptions.keepErrors ? _formState.errors : {},\r\n            isSubmitting: false,\r\n            isSubmitSuccessful: false,\r\n        });\r\n    };\r\n    const reset = (formValues, keepStateOptions) => _reset(isFunction(formValues)\r\n        ? formValues(_formValues)\r\n        : formValues, keepStateOptions);\r\n    const setFocus = (name, options = {}) => {\r\n        const field = get(_fields, name);\r\n        const fieldReference = field && field._f;\r\n        if (fieldReference) {\r\n            const fieldRef = fieldReference.refs\r\n                ? fieldReference.refs[0]\r\n                : fieldReference.ref;\r\n            if (fieldRef.focus) {\r\n                fieldRef.focus();\r\n                options.shouldSelect && fieldRef.select();\r\n            }\r\n        }\r\n    };\r\n    const _updateFormState = (updatedFormState) => {\r\n        _formState = {\r\n            ..._formState,\r\n            ...updatedFormState,\r\n        };\r\n    };\r\n    if (isFunction(_options.defaultValues)) {\r\n        _options.defaultValues().then((values) => {\r\n            reset(values, _options.resetOptions);\r\n            _subjects.state.next({\r\n                isLoading: false,\r\n            });\r\n        });\r\n    }\r\n    return {\r\n        control: {\r\n            register,\r\n            unregister,\r\n            getFieldState,\r\n            _executeSchema,\r\n            _getWatch,\r\n            _getDirty,\r\n            _updateValid,\r\n            _removeUnmounted,\r\n            _updateFieldArray,\r\n            _getFieldArray,\r\n            _reset,\r\n            _updateFormState,\r\n            _subjects,\r\n            _proxyFormState,\r\n            get _fields() {\r\n                return _fields;\r\n            },\r\n            get _formValues() {\r\n                return _formValues;\r\n            },\r\n            get _state() {\r\n                return _state;\r\n            },\r\n            set _state(value) {\r\n                _state = value;\r\n            },\r\n            get _defaultValues() {\r\n                return _defaultValues;\r\n            },\r\n            get _names() {\r\n                return _names;\r\n            },\r\n            set _names(value) {\r\n                _names = value;\r\n            },\r\n            get _formState() {\r\n                return _formState;\r\n            },\r\n            set _formState(value) {\r\n                _formState = value;\r\n            },\r\n            get _options() {\r\n                return _options;\r\n            },\r\n            set _options(value) {\r\n                _options = {\r\n                    ..._options,\r\n                    ...value,\r\n                };\r\n            },\r\n        },\r\n        trigger,\r\n        register,\r\n        handleSubmit,\r\n        watch,\r\n        setValue,\r\n        getValues,\r\n        reset,\r\n        resetField,\r\n        clearErrors,\r\n        unregister,\r\n        setError,\r\n        setFocus,\r\n        getFieldState,\r\n    };\r\n}\n\n/**\r\n * Custom hook to manage the entire form.\r\n *\r\n * @remarks\r\n * [API](https://react-hook-form.com/api/useform) • [Demo](https://codesandbox.io/s/react-hook-form-get-started-ts-5ksmm) • [Video](https://www.youtube.com/watch?v=RkXv4AXXC_4)\r\n *\r\n * @param props - form configuration and validation parameters.\r\n *\r\n * @returns methods - individual functions to manage the form state. {@link UseFormReturn}\r\n *\r\n * @example\r\n * ```tsx\r\n * function App() {\r\n *   const { register, handleSubmit, watch, formState: { errors } } = useForm();\r\n *   const onSubmit = data => console.log(data);\r\n *\r\n *   console.log(watch(\"example\"));\r\n *\r\n *   return (\r\n *     <form onSubmit={handleSubmit(onSubmit)}>\r\n *       <input defaultValue=\"test\" {...register(\"example\")} />\r\n *       <input {...register(\"exampleRequired\", { required: true })} />\r\n *       {errors.exampleRequired && <span>This field is required</span>}\r\n *       <input type=\"submit\" />\r\n *     </form>\r\n *   );\r\n * }\r\n * ```\r\n */\r\nfunction useForm(props = {}) {\r\n    const _formControl = React__default[\"default\"].useRef();\r\n    const [formState, updateFormState] = React__default[\"default\"].useState({\r\n        isDirty: false,\r\n        isValidating: false,\r\n        isLoading: true,\r\n        isSubmitted: false,\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: false,\r\n        submitCount: 0,\r\n        dirtyFields: {},\r\n        touchedFields: {},\r\n        errors: {},\r\n        defaultValues: isFunction(props.defaultValues)\r\n            ? undefined\r\n            : props.defaultValues,\r\n    });\r\n    if (!_formControl.current) {\r\n        _formControl.current = {\r\n            ...createFormControl(props, () => updateFormState((formState) => ({ ...formState }))),\r\n            formState,\r\n        };\r\n    }\r\n    const control = _formControl.current.control;\r\n    control._options = props;\r\n    useSubscribe({\r\n        subject: control._subjects.state,\r\n        next: (value) => {\r\n            if (shouldRenderFormState(value, control._proxyFormState, control._updateFormState, true)) {\r\n                updateFormState({ ...control._formState });\r\n            }\r\n        },\r\n    });\r\n    React__default[\"default\"].useEffect(() => {\r\n        if (props.values && !deepEqual(props.values, control._defaultValues)) {\r\n            control._reset(props.values, control._options.resetOptions);\r\n        }\r\n    }, [props.values, control]);\r\n    React__default[\"default\"].useEffect(() => {\r\n        if (!control._state.mount) {\r\n            control._updateValid();\r\n            control._state.mount = true;\r\n        }\r\n        if (control._state.watch) {\r\n            control._state.watch = false;\r\n            control._subjects.state.next({ ...control._formState });\r\n        }\r\n        control._removeUnmounted();\r\n    });\r\n    _formControl.current.formState = getProxyFormState(formState, control);\r\n    return _formControl.current;\r\n}\n\nvar colors = {\r\n    primary: '#0e101c',\r\n    secondary: '#bf1650',\r\n    lightBlue: '#516391',\r\n    blue: '#1e2a4a',\r\n    lightPink: '#ec5990',\r\n    errorPink: '#fbecf2',\r\n    buttonBlue: '#191d3a',\r\n    link: '#ff7aa8',\r\n    green: '#1bda2b',\r\n};\n\nconst paraGraphDefaultStyle = {\r\n    fontSize: 13,\r\n    lineHeight: '20px',\r\n};\r\nconst Button = styled__default[\"default\"].button `\n  appearance: none;\n  margin: 0;\n  border: 0;\n  color: white;\n  padding: 5px !important;\n  border-radius: 0 !important;\n  background: ${(props) => props.hideBackground ? `` : `${colors.blue} !important`};\n  transition: 0.2s all;\n\n  &:hover {\n    background: ${colors.lightBlue};\n  }\n`;\r\nButton.defaultProps = { type: 'button' };\r\nconst CircleButton = styled__default[\"default\"](Button) `\n  font-size: 14px;\n  font-weight: bold;\n  margin: 0 4px 0 auto;\n  background: none !important;\n  display: flex;\n  width: 25px;\n  height: 25px;\n  justify-content: center;\n  line-height: 14px !important;\n  border-radius: 50% !important;\n  padding: 0 !important;\n  transition: 0.2s all;\n\n  &:hover {\n    background: ${colors.lightBlue};\n  }\n\n  &:active {\n    background: black;\n  }\n`;\r\nconst Input = styled__default[\"default\"].input `\n  &::placeholder {\n    color: #b3b3b3;\n  }\n\n  &:focus::placeholder {\n    color: white;\n  }\n`;\r\nconst Table = styled__default[\"default\"].table `\n  transition: 0.3s all;\n\n  &:hover {\n    background: ${colors.primary};\n  }\n`;\n\nconst Header = ({ setVisible, control }) => {\r\n    const { isValid } = useFormState({\r\n        control,\r\n    });\r\n    return (React__namespace.createElement(\"header\", { style: {\r\n            display: 'flex',\r\n            alignItems: 'center',\r\n            paddingLeft: 10,\r\n            backgroundColor: 'transparent',\r\n        } },\r\n        React__namespace.createElement(\"p\", { style: Object.assign(Object.assign({}, paraGraphDefaultStyle), { margin: 0, padding: 0, fontWeight: 400, fontSize: 12 }) },\r\n            React__namespace.createElement(\"span\", { style: {\r\n                    transition: '0.5s all',\r\n                    color: isValid ? colors.green : colors.lightPink,\r\n                } }, \"\\u25A0\"),\r\n            ' ',\r\n            \"React Hook Form\"),\r\n        React__namespace.createElement(CircleButton, { title: \"Close dev panel\", onClick: () => setVisible(false) }, \"\\u2715\")));\r\n};\n\nconst PanelTable = ({ refObject, hasError, isDirty, fieldsValues, isNative, errorMessage, errorType, type, isTouched, name, collapseAll, }) => {\r\n    const [collapse, setCollapse] = React__namespace.useState(false);\r\n    React__namespace.useEffect(() => {\r\n        setCollapse(!collapseAll);\r\n    }, [collapseAll]);\r\n    let value = fieldsValues ? get(fieldsValues, name) : '';\r\n    let isValueWrappedInPre = false;\r\n    if (!isUndefined__default[\"default\"](value)) {\r\n        if (isObject__default[\"default\"](value)) {\r\n            try {\r\n                value = (React__namespace.createElement(\"pre\", { style: { margin: 0 } },\r\n                    React__namespace.createElement(\"code\", { style: { fontSize: 12 } }, JSON.stringify(value, null, 2))));\r\n                isValueWrappedInPre = true;\r\n            }\r\n            catch (_a) {\r\n                value = React__namespace.createElement(\"span\", null, \"[Nested Object]\");\r\n            }\r\n        }\r\n        else if (typeof value !== 'string') {\r\n            value = String(value);\r\n        }\r\n    }\r\n    return (React__namespace.createElement(Table, { style: {\r\n            padding: '5px 8px',\r\n            width: '100%',\r\n            transition: '.3s all',\r\n            borderLeft: `2px solid ${hasError ? colors.secondary : colors.buttonBlue}`,\r\n            background: 'none',\r\n        } },\r\n        React__namespace.createElement(\"thead\", null,\r\n            React__namespace.createElement(\"tr\", null,\r\n                React__namespace.createElement(\"td\", { valign: \"top\", style: { width: 85, lineHeight: '22px' } },\r\n                    React__namespace.createElement(Button, { onClick: () => setCollapse(!collapse), title: \"Toggle field table\", style: {\r\n                            border: `1px solid ${colors.lightBlue}`,\r\n                            borderRadius: 2,\r\n                            padding: '3px 5px',\r\n                            display: 'inline-block',\r\n                            fontSize: 9,\r\n                            lineHeight: '13px',\r\n                            width: 20,\r\n                            textAlign: 'center',\r\n                            marginRight: 8,\r\n                        } }, collapse ? '+' : '-'),\r\n                    React__namespace.createElement(Button, { onClick: () => {\r\n                            if (refObject.scrollIntoView) {\r\n                                refObject.scrollIntoView({ behavior: 'smooth' });\r\n                            }\r\n                        }, title: \"Scroll into view\", style: Object.assign({ border: `1px solid ${colors.lightBlue}`, borderRadius: 2, padding: '3px 5px', display: 'inline-block', fontSize: 9, lineHeight: '13px', textAlign: 'center', width: 'calc(100% - 30px)' }, (isNative\r\n                            ? {}\r\n                            : { cursor: 'not-allowed', background: colors.lightBlue })) }, isNative ? 'Native' : 'Custom')),\r\n                React__namespace.createElement(\"td\", { style: {\r\n                        display: 'block',\r\n                        maxWidth: 140,\r\n                    } },\r\n                    React__namespace.createElement(\"p\", { style: Object.assign(Object.assign({ margin: 0, padding: 0, top: 0, position: 'relative', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }, paraGraphDefaultStyle), { lineHeight: '24px' }), title: name }, name)))),\r\n        !collapse && (React__namespace.createElement(\"tbody\", null,\r\n            type && (React__namespace.createElement(\"tr\", null,\r\n                React__namespace.createElement(\"td\", { align: \"right\", style: Object.assign({ paddingRight: 5, fontWeight: 500, verticalAlign: 'top' }, paraGraphDefaultStyle) }, \"Type:\"),\r\n                React__namespace.createElement(\"td\", { style: Object.assign({ display: 'block', maxWidth: 100 }, paraGraphDefaultStyle) }, type))),\r\n            errorType && (React__namespace.createElement(\"tr\", null,\r\n                React__namespace.createElement(\"td\", { align: \"right\", style: Object.assign({ paddingRight: 5, fontWeight: 500, verticalAlign: 'top' }, paraGraphDefaultStyle) }, \"ERROR Type:\"),\r\n                React__namespace.createElement(\"td\", { style: Object.assign({ display: 'block', maxWidth: 100 }, paraGraphDefaultStyle) }, errorType))),\r\n            errorMessage && (React__namespace.createElement(\"tr\", null,\r\n                React__namespace.createElement(\"td\", { align: \"right\", style: Object.assign({ paddingRight: 5, fontWeight: 500, verticalAlign: 'top' }, paraGraphDefaultStyle) }, \"MESSAGE:\"),\r\n                React__namespace.createElement(\"td\", { style: Object.assign({ display: 'block', maxWidth: 100 }, paraGraphDefaultStyle) }, typeof errorMessage === 'string'\r\n                    ? errorMessage.trim()\r\n                    : JSON.stringify(errorMessage)))),\r\n            !isUndefined__default[\"default\"](value) && (React__namespace.createElement(\"tr\", null,\r\n                React__namespace.createElement(\"td\", { align: \"right\", style: Object.assign({ paddingRight: 5, fontWeight: 500, verticalAlign: 'top' }, paraGraphDefaultStyle) }, \"Value:\"),\r\n                React__namespace.createElement(\"td\", { \"data-testid\": `${name}-field-value`, style: Object.assign({ display: 'block', maxWidth: 100 }, paraGraphDefaultStyle) },\r\n                    !isValueWrappedInPre && (React__namespace.createElement(\"p\", { title: value, style: Object.assign(Object.assign({}, paraGraphDefaultStyle), { margin: 0, padding: 0 }) }, value)),\r\n                    isValueWrappedInPre && (React__namespace.createElement(\"div\", { style: Object.assign(Object.assign({}, paraGraphDefaultStyle), { margin: 0, padding: 0 }) }, value))))),\r\n            React__namespace.createElement(\"tr\", null,\r\n                React__namespace.createElement(\"td\", { align: \"right\", style: Object.assign({ paddingRight: 5, fontWeight: 500, verticalAlign: 'top' }, paraGraphDefaultStyle) }, \"Touched:\"),\r\n                React__namespace.createElement(\"td\", null,\r\n                    React__namespace.createElement(\"code\", { style: Object.assign(Object.assign({ color: isTouched ? colors.green : colors.lightPink }, paraGraphDefaultStyle), { fontSize: 12 }) }, isTouched ? 'true' : 'false'))),\r\n            React__namespace.createElement(\"tr\", null,\r\n                React__namespace.createElement(\"td\", { align: \"right\", style: Object.assign({ paddingRight: 5, fontWeight: 500, verticalAlign: 'top' }, paraGraphDefaultStyle) }, \"Dirty:\"),\r\n                React__namespace.createElement(\"td\", null,\r\n                    React__namespace.createElement(\"code\", { style: Object.assign(Object.assign({ color: isDirty ? colors.green : colors.lightPink }, paraGraphDefaultStyle), { fontSize: 12 }) }, isDirty ? 'true' : 'false')))))));\r\n};\n\nconst FormStateTable = ({ formState, showFormState, setShowFormState, }) => (React__namespace.createElement(\"div\", { style: {\r\n        alignSelf: 'end',\r\n    } },\r\n    React__namespace.createElement(reactSimpleAnimate.Animate, { play: showFormState, start: { opacity: 0 }, end: { opacity: 1 }, render: ({ style }) => (React__namespace.createElement(\"table\", { style: Object.assign({ padding: '5px 10px', display: 'block', background: 'black', borderTop: `1px solid ${colors.lightPink}`, pointerEvents: 'none' }, style) },\r\n            React__namespace.createElement(\"tbody\", null,\r\n                React__namespace.createElement(\"tr\", null,\r\n                    React__namespace.createElement(\"td\", { align: \"right\", style: Object.assign({ width: 90 }, paraGraphDefaultStyle) }, \"Valid:\"),\r\n                    React__namespace.createElement(\"td\", { style: Object.assign({ color: formState.isValid ? colors.green : colors.lightPink }, paraGraphDefaultStyle) }, formState.isValid ? 'true' : 'false')),\r\n                React__namespace.createElement(\"tr\", null,\r\n                    React__namespace.createElement(\"td\", { align: \"right\", style: Object.assign({}, paraGraphDefaultStyle) }, \"Dirty:\"),\r\n                    React__namespace.createElement(\"td\", { style: Object.assign({ color: formState.isDirty ? colors.green : colors.lightPink }, paraGraphDefaultStyle) }, formState.isDirty ? 'true' : 'false')),\r\n                React__namespace.createElement(\"tr\", null,\r\n                    React__namespace.createElement(\"td\", { align: \"right\", style: Object.assign({}, paraGraphDefaultStyle) }, \"Submitted:\"),\r\n                    React__namespace.createElement(\"td\", { style: Object.assign({ color: formState.isSubmitted\r\n                                ? colors.green\r\n                                : colors.lightPink }, paraGraphDefaultStyle) }, formState.isSubmitted ? 'true' : 'false')),\r\n                React__namespace.createElement(\"tr\", null,\r\n                    React__namespace.createElement(\"td\", { align: \"right\", style: Object.assign({}, paraGraphDefaultStyle) }, \"Count:\"),\r\n                    React__namespace.createElement(\"td\", { style: Object.assign({ color: formState.submitCount\r\n                                ? colors.green\r\n                                : colors.lightPink }, paraGraphDefaultStyle) }, formState.submitCount)),\r\n                React__namespace.createElement(\"tr\", null,\r\n                    React__namespace.createElement(\"td\", { align: \"right\", style: Object.assign({}, paraGraphDefaultStyle) }, \"Submitting:\"),\r\n                    React__namespace.createElement(\"td\", { style: Object.assign({ color: formState.isSubmitting\r\n                                ? colors.green\r\n                                : colors.lightPink }, paraGraphDefaultStyle) }, formState.isSubmitting ? 'true' : 'false'))))) }),\r\n    React__namespace.createElement(Button, { style: {\r\n            margin: 0,\r\n            width: '100%',\r\n            padding: '8px 10px',\r\n            textTransform: 'none',\r\n            fontSize: 12,\r\n            lineHeight: '14px',\r\n            cursor: 'pointer',\r\n        }, title: \"Toggle form state panel\", onClick: () => {\r\n            setShowFormState(!showFormState);\r\n        } },\r\n        React__namespace.createElement(\"span\", { style: {\r\n                transition: '0.5s all',\r\n                color: formState.isValid ? colors.green : colors.lightPink,\r\n            } }, \"\\u25A0\"),\r\n        ' ',\r\n        \"Form State: \",\r\n        showFormState ? 'OFF' : 'ON')));\n\nfunction setVisible(state, payload) {\r\n    return Object.assign(Object.assign({}, state), { visible: payload });\r\n}\r\nfunction setCollapse(state, payload) {\r\n    return Object.assign(Object.assign({}, state), { isCollapse: payload });\r\n}\n\nlet childIndex = 0;\r\nfunction PanelChildren({ fields, searchTerm, touchedFields, errors, dirtyFields, state, fieldsValues, }) {\r\n    return (React__namespace.createElement(React__namespace.Fragment, null, fields &&\r\n        Object.entries(fields)\r\n            .filter(([name]) => ((name &&\r\n            name.toLowerCase &&\r\n            name.toLowerCase().includes(searchTerm)) ||\r\n            (!name && !searchTerm) ||\r\n            searchTerm === '') &&\r\n            name)\r\n            .map(([name, value], index) => {\r\n            childIndex++;\r\n            if (!(value === null || value === void 0 ? void 0 : value._f)) {\r\n                return (React__namespace.createElement(PanelChildren, Object.assign({ key: name + childIndex }, {\r\n                    fields: value,\r\n                    searchTerm,\r\n                    touchedFields,\r\n                    errors,\r\n                    dirtyFields,\r\n                    state,\r\n                    fieldsValues,\r\n                })));\r\n            }\r\n            else {\r\n                const error = get(errors, value._f.name);\r\n                const errorMessage = get(error, 'message', undefined);\r\n                const errorType = get(error, 'type', undefined);\r\n                const type = get(value, 'ref.type', undefined);\r\n                const isTouched = !!get(touchedFields, value._f.name);\r\n                const isNative = !!(value && value._f.ref.type);\r\n                const isDirty = !!get(dirtyFields, value._f.name);\r\n                const hasError = !!error;\r\n                const ref = get(value, '_f.ref');\r\n                return (React__namespace.createElement(\"section\", { key: (value === null || value === void 0 ? void 0 : value._f.name) + childIndex, style: {\r\n                        borderBottom: `1px dashed ${colors.secondary}`,\r\n                        margin: 0,\r\n                    } },\r\n                    React__namespace.createElement(PanelTable, { refObject: ref, index: index, collapseAll: state.isCollapse, name: value === null || value === void 0 ? void 0 : value._f.name, isTouched: isTouched, type: type, hasError: hasError, isNative: isNative, errorMessage: errorMessage, errorType: errorType, isDirty: isDirty, fieldsValues: fieldsValues })));\r\n            }\r\n        })));\r\n}\r\nconst Panel = ({ control, control: { _fields } }) => {\r\n    const formState = useFormState({\r\n        control,\r\n    });\r\n    const { dirtyFields, touchedFields, errors } = formState;\r\n    formState.isDirty;\r\n    const { state, actions } = littleStateMachine.useStateMachine({\r\n        setCollapse,\r\n    });\r\n    const [, setData] = React__namespace.useState({});\r\n    const [showFormState, setShowFormState] = React__namespace.useState(false);\r\n    const fieldsValues = useWatch({\r\n        control,\r\n    });\r\n    const { register, watch } = useForm();\r\n    const searchTerm = watch('search', '');\r\n    React.useEffect(() => {\r\n        setData({});\r\n    }, []);\r\n    return (React__namespace.createElement(\"div\", { style: {\r\n            display: 'grid',\r\n            gridTemplateRows: '56px auto',\r\n            height: 'calc(100vh - 40px)',\r\n        } },\r\n        React__namespace.createElement(\"div\", { style: {\r\n                display: 'grid',\r\n                gridTemplateColumns: `1fr 1fr`,\r\n                gridTemplateRows: '28px 28px',\r\n            } },\r\n            React__namespace.createElement(Button, { style: {\r\n                    borderRight: `1px solid ${colors.primary}`,\r\n                    textTransform: 'none',\r\n                    fontSize: 11,\r\n                    lineHeight: 1,\r\n                }, title: \"Update values and state the form\", onClick: () => setData({}) }, \"\\u267A REFRESH\"),\r\n            React__namespace.createElement(Button, { style: {\r\n                    borderRight: `1px solid ${colors.primary}`,\r\n                    textTransform: 'none',\r\n                    fontSize: 11,\r\n                    lineHeight: 1,\r\n                }, title: \"Toggle entire fields\", onClick: () => {\r\n                    actions.setCollapse(!state.isCollapse);\r\n                } }, state.isCollapse ? '[-] COLLAPSE' : '[+] EXPAND'),\r\n            React__namespace.createElement(Input, Object.assign({ style: {\r\n                    display: 'inline-block',\r\n                    borderRadius: 0,\r\n                    width: '100%',\r\n                    margin: 0,\r\n                    padding: '5px 10px',\r\n                    WebkitAppearance: 'none',\r\n                    appearance: 'none',\r\n                    fontSize: 14,\r\n                    border: 0,\r\n                    color: 'white',\r\n                    gridColumnStart: 1,\r\n                    gridColumnEnd: 4,\r\n                    background: 'black',\r\n                } }, register('search'), { placeholder: \"Filter name...\", type: \"search\" }))),\r\n        React__namespace.createElement(\"div\", { style: {\r\n                overflow: 'auto',\r\n            } },\r\n            React__namespace.createElement(PanelChildren, { fields: _fields, searchTerm: searchTerm, errors: errors, touchedFields: touchedFields, dirtyFields: dirtyFields, fieldsValues: fieldsValues, state: state })),\r\n        React__namespace.createElement(FormStateTable, { formState: formState, showFormState: showFormState, setShowFormState: setShowFormState })));\r\n};\n\nconst Logo = ({ style, actions, }) => {\r\n    return (React__namespace.createElement(\"svg\", { fill: \"white\", viewBox: \"0 0 100 100\", style: Object.assign({ height: 14, padding: 3, borderRadius: 2, background: colors.lightPink }, style), onClick: () => {\r\n            actions.setVisible(true);\r\n        }, \"aria-label\": \"React Hook Form Logo\" },\r\n        React__namespace.createElement(\"path\", { d: \"M73.56,13.32H58.14a8.54,8.54,0,0,0-16.27,0H26.44a11,11,0,0,0-11,11V81.63a11,11,0,0,0,11,11H73.56a11,11,0,0,0,11-11V24.32A11,11,0,0,0,73.56,13.32Zm-30.92,2a1,1,0,0,0,1-.79,6.54,6.54,0,0,1,12.78,0,1,1,0,0,0,1,.79h5.38v6.55a3,3,0,0,1-3,3H40.25a3,3,0,0,1-3-3V15.32ZM82.56,81.63a9,9,0,0,1-9,9H26.44a9,9,0,0,1-9-9V24.32a9,9,0,0,1,9-9h8.81v6.55a5,5,0,0,0,5,5h19.5a5,5,0,0,0,5-5V15.32h8.81a9,9,0,0,1,9,9Z\" }),\r\n        React__namespace.createElement(\"path\", { style: { transform: 'translateX(-25px)' }, d: \"M71.6,45.92H54a1,1,0,0,0,0,2H71.6a1,1,0,0,0,0-2Z\" }),\r\n        React__namespace.createElement(\"path\", { d: \"M71.6,45.92H54a1,1,0,0,0,0,2H71.6a1,1,0,0,0,0-2Z\" }),\r\n        React__namespace.createElement(\"path\", { style: { transform: 'translateX(-25px)' }, d: \"M71.1,69.49H53.45a1,1,0,1,0,0,2H71.1a1,1,0,0,0,0-2Z\" }),\r\n        React__namespace.createElement(\"path\", { d: \"M71.1,69.49H53.45a1,1,0,1,0,0,2H71.1a1,1,0,0,0,0-2Z\" })));\r\n};\n\nfunction getPositionByPlacement(placement, defaultX = 0, defaultY = 0) {\r\n    const [x, y] = placement.split('-');\r\n    return {\r\n        [x]: defaultX,\r\n        [y]: defaultY,\r\n    };\r\n}\n\nconst DevToolUI = ({ control, placement = 'top-right', styles, }) => {\r\n    const { state, actions } = littleStateMachine.useStateMachine({\r\n        setVisible,\r\n    });\r\n    const position = getPositionByPlacement(placement, 0, 0);\r\n    return (React__namespace.createElement(React__namespace.Fragment, null,\r\n        React__namespace.createElement(reactSimpleAnimate.Animate, { play: state.visible, duration: 0.2, start: Object.assign(Object.assign({}, position), { position: 'fixed', transform: placement.includes('right')\r\n                    ? 'translateX(280px)'\r\n                    : 'translateX(-280px)', zIndex: 99999 }), end: Object.assign(Object.assign({}, position), { position: 'fixed', transform: 'translateX(0)', zIndex: 99999 }) },\r\n            React__namespace.createElement(\"div\", { style: Object.assign(Object.assign(Object.assign({}, position), { position: 'fixed', height: '100vh', width: 250, zIndex: 99999, background: colors.buttonBlue, display: 'grid', textAlign: 'left', color: 'white', fontSize: 14, gridTemplateRows: '40px auto', fontFamily: \"-apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif\" }), styles === null || styles === void 0 ? void 0 : styles.panel) },\r\n                React__namespace.createElement(Header, { setVisible: actions.setVisible, control: control }),\r\n                React__namespace.createElement(Panel, { control: control }))),\r\n        !state.visible && (React__namespace.createElement(Button, { title: \"Show dev panel\", hideBackground: true, style: Object.assign(Object.assign(Object.assign({ position: 'fixed', zIndex: 99999 }, getPositionByPlacement(placement, 3, 3)), { padding: 3, margin: 0, background: 'none' }), styles === null || styles === void 0 ? void 0 : styles.button) },\r\n            React__namespace.createElement(Logo, { actions: actions })))));\r\n};\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nfunction proxyToObject(proxy) {\r\n    return Reflect.ownKeys(proxy).reduce((prev, key) => {\r\n        prev[key] = proxy[key];\r\n        return prev;\r\n    }, {});\r\n}\r\nfunction nestToFlat(flatKeys, obj, defaultValue) {\r\n    return flatKeys.reduce((prev, name) => {\r\n        // nested field may be `undefined`\r\n        prev[name] = get__default[\"default\"](obj, name) || defaultValue;\r\n        return prev;\r\n    }, {});\r\n}\n\nfunction useExportControlToExtension({ id, control, }) {\r\n    const nestedFormValues = useWatch({ control });\r\n    const formState = useFormState({ control });\r\n    const [isExtensionEnabled, setIsExtensionEnabled] = React.useState(false);\r\n    const handleInitMessage = (message) => {\r\n        if (message.data.source !== 'react-hook-form-bridge' ||\r\n            message.data.type !== 'INIT') {\r\n            return;\r\n        }\r\n        window.postMessage({\r\n            source: 'react-hook-form-bridge',\r\n            type: 'WELCOME',\r\n        });\r\n        setIsExtensionEnabled(true);\r\n    };\r\n    React.useEffect(() => {\r\n        window.addEventListener('message', handleInitMessage);\r\n        return () => window.removeEventListener('message', handleInitMessage);\r\n    }, []);\r\n    useDeepCompareEffect__default[\"default\"](() => {\r\n        if (!isExtensionEnabled) {\r\n            return;\r\n        }\r\n        const _a = proxyToObject(formState), { errors: nestedErrors, dirtyFields: nestedDirtyFields, touchedFields: nestedTouchedFields } = _a, formStatus = __rest(_a, [\"errors\", \"dirtyFields\", \"touchedFields\"]);\r\n        const flatFieldNames = [...control._names.mount];\r\n        const formValues = nestToFlat(flatFieldNames, nestedFormValues, '');\r\n        const dirtyFields = nestToFlat(flatFieldNames, nestedDirtyFields, false);\r\n        const touchedFields = nestToFlat(flatFieldNames, nestedTouchedFields, false);\r\n        const flatErrors = nestToFlat(flatFieldNames, nestedErrors);\r\n        const errors = Object.entries(flatErrors).reduce((prev, [key, value]) => {\r\n            prev[key] = {\r\n                type: value === null || value === void 0 ? void 0 : value.type,\r\n                message: value === null || value === void 0 ? void 0 : value.message,\r\n            };\r\n            return prev;\r\n        }, {});\r\n        const nativeFields = flatFieldNames.reduce((prev, name) => {\r\n            var _a, _b, _c;\r\n            prev[name] = !!((_c = (_b = (_a = get__default[\"default\"](control._fields, name)) === null || _a === void 0 ? void 0 : _a._f) === null || _b === void 0 ? void 0 : _b.ref) === null || _c === void 0 ? void 0 : _c.type);\r\n            return prev;\r\n        }, {});\r\n        const updateMessagePayload = {\r\n            id,\r\n            data: {\r\n                formValues,\r\n                formState: Object.assign({ errors,\r\n                    dirtyFields,\r\n                    touchedFields,\r\n                    nativeFields }, formStatus),\r\n            },\r\n        };\r\n        window.postMessage({\r\n            source: 'react-hook-form-bridge',\r\n            type: 'UPDATE',\r\n            payload: updateMessagePayload,\r\n        });\r\n    }, [isExtensionEnabled, nestedFormValues, proxyToObject(formState)]);\r\n    return { isExtensionEnabled };\r\n}\n\nif (typeof window !== 'undefined') {\r\n    littleStateMachine.createStore({\r\n        visible: false,\r\n        isCollapse: false,\r\n        filterName: '',\r\n    }, {\r\n        name: '__REACT_HOOK_FORM_DEVTOOLS__',\r\n        middleWares: [],\r\n        storageType: window.localStorage,\r\n    });\r\n}\r\nconst DevTool = (props) => {\r\n    var _a, _b, _c;\r\n    const methods = useFormContext();\r\n    const uuid$1 = React__namespace.useRef('');\r\n    React__namespace.useEffect(() => {\r\n        uuid$1.current = uuid.v4();\r\n    }, []);\r\n    const { isExtensionEnabled } = useExportControlToExtension({\r\n        id: (_a = props === null || props === void 0 ? void 0 : props.id) !== null && _a !== void 0 ? _a : uuid$1.current,\r\n        control: (_b = props === null || props === void 0 ? void 0 : props.control) !== null && _b !== void 0 ? _b : methods.control,\r\n    });\r\n    if (isExtensionEnabled) {\r\n        return null;\r\n    }\r\n    return (React__namespace.createElement(littleStateMachine.StateMachineProvider, null,\r\n        React__namespace.createElement(DevToolUI, { control: (_c = props === null || props === void 0 ? void 0 : props.control) !== null && _c !== void 0 ? _c : methods.control, placement: props === null || props === void 0 ? void 0 : props.placement, styles: props === null || props === void 0 ? void 0 : props.styles })));\r\n};\n\nexports.DevTool = DevTool;\n//# sourceMappingURL=index.cjs.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGhvb2tmb3JtL2RldnRvb2xzL2Rpc3QvaW5kZXguY2pzLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QseUJBQXlCLG1CQUFPLENBQUMsdUdBQXNCO0FBQ3ZELFlBQVksbUJBQU8sQ0FBQyx3R0FBTztBQUMzQixXQUFXLG1CQUFPLENBQUMsOERBQU07QUFDekIseUJBQXlCLG1CQUFPLENBQUMscUZBQXNCO0FBQ3ZELGFBQWEsbUJBQU8sQ0FBQyxvR0FBaUI7QUFDdEMsb0JBQW9CLG1CQUFPLENBQUMsc0VBQW9CO0FBQ2hELGlCQUFpQixtQkFBTyxDQUFDLGdFQUFpQjtBQUMxQyxZQUFZLG1CQUFPLENBQUMsc0RBQVk7QUFDaEMsMkJBQTJCLG1CQUFPLENBQUMsaUhBQXlCOztBQUU1RCxxQ0FBcUMsNERBQTREOztBQUVqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxnSEFBZ0g7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0Msd0NBQXdDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsNFFBQTRRO0FBQ2hVOztBQUVBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3BhdGllbmNlX2FsY2hlbXkvLi9ub2RlX21vZHVsZXMvQGhvb2tmb3JtL2RldnRvb2xzL2Rpc3QvaW5kZXguY2pzLmRldmVsb3BtZW50LmpzPzQwZTIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgbGl0dGxlU3RhdGVNYWNoaW5lID0gcmVxdWlyZSgnbGl0dGxlLXN0YXRlLW1hY2hpbmUnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQnKTtcbnZhciByZWFjdFNpbXBsZUFuaW1hdGUgPSByZXF1aXJlKCdyZWFjdC1zaW1wbGUtYW5pbWF0ZScpO1xudmFyIHN0eWxlZCA9IHJlcXVpcmUoJ0BlbW90aW9uL3N0eWxlZCcpO1xudmFyIGlzVW5kZWZpbmVkJDEgPSByZXF1aXJlKCdsb2Rhc2gvaXNVbmRlZmluZWQnKTtcbnZhciBpc09iamVjdCQxID0gcmVxdWlyZSgnbG9kYXNoL2lzT2JqZWN0Jyk7XG52YXIgZ2V0JDEgPSByZXF1aXJlKCdsb2Rhc2gvZ2V0Jyk7XG52YXIgdXNlRGVlcENvbXBhcmVFZmZlY3QgPSByZXF1aXJlKCd1c2UtZGVlcC1jb21wYXJlLWVmZmVjdCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3kgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2UoZSkge1xuICAgIGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG4gICAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChlKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuW1wiZGVmYXVsdFwiXSA9IGU7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5cbnZhciBSZWFjdF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koUmVhY3QpO1xudmFyIFJlYWN0X19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UoUmVhY3QpO1xudmFyIHN0eWxlZF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koc3R5bGVkKTtcbnZhciBpc1VuZGVmaW5lZF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koaXNVbmRlZmluZWQkMSk7XG52YXIgaXNPYmplY3RfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KGlzT2JqZWN0JDEpO1xudmFyIGdldF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koZ2V0JDEpO1xudmFyIHVzZURlZXBDb21wYXJlRWZmZWN0X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeSh1c2VEZWVwQ29tcGFyZUVmZmVjdCk7XG5cbnZhciBpc0NoZWNrQm94SW5wdXQgPSAoZWxlbWVudCkgPT4gZWxlbWVudC50eXBlID09PSAnY2hlY2tib3gnO1xuXG52YXIgaXNEYXRlT2JqZWN0ID0gKHZhbHVlKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIERhdGU7XG5cbnZhciBpc051bGxPclVuZGVmaW5lZCA9ICh2YWx1ZSkgPT4gdmFsdWUgPT0gbnVsbDtcblxuY29uc3QgaXNPYmplY3RUeXBlID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xyXG52YXIgaXNPYmplY3QgPSAodmFsdWUpID0+ICFpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkgJiZcclxuICAgICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJlxyXG4gICAgaXNPYmplY3RUeXBlKHZhbHVlKSAmJlxyXG4gICAgIWlzRGF0ZU9iamVjdCh2YWx1ZSk7XG5cbnZhciBnZXRFdmVudFZhbHVlID0gKGV2ZW50KSA9PiBpc09iamVjdChldmVudCkgJiYgZXZlbnQudGFyZ2V0XHJcbiAgICA/IGlzQ2hlY2tCb3hJbnB1dChldmVudC50YXJnZXQpXHJcbiAgICAgICAgPyBldmVudC50YXJnZXQuY2hlY2tlZFxyXG4gICAgICAgIDogZXZlbnQudGFyZ2V0LnZhbHVlXHJcbiAgICA6IGV2ZW50O1xuXG52YXIgZ2V0Tm9kZVBhcmVudE5hbWUgPSAobmFtZSkgPT4gbmFtZS5zdWJzdHJpbmcoMCwgbmFtZS5zZWFyY2goL1xcLlxcZCsoXFwufCQpLykpIHx8IG5hbWU7XG5cbnZhciBpc05hbWVJbkZpZWxkQXJyYXkgPSAobmFtZXMsIG5hbWUpID0+IG5hbWVzLmhhcyhnZXROb2RlUGFyZW50TmFtZShuYW1lKSk7XG5cbnZhciBpc1BsYWluT2JqZWN0ID0gKHRlbXBPYmplY3QpID0+IHtcclxuICAgIGNvbnN0IHByb3RvdHlwZUNvcHkgPSB0ZW1wT2JqZWN0LmNvbnN0cnVjdG9yICYmIHRlbXBPYmplY3QuY29uc3RydWN0b3IucHJvdG90eXBlO1xyXG4gICAgcmV0dXJuIChpc09iamVjdChwcm90b3R5cGVDb3B5KSAmJiBwcm90b3R5cGVDb3B5Lmhhc093blByb3BlcnR5KCdpc1Byb3RvdHlwZU9mJykpO1xyXG59O1xuXG52YXIgaXNXZWIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgdHlwZW9mIHdpbmRvdy5IVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbmZ1bmN0aW9uIGNsb25lT2JqZWN0KGRhdGEpIHtcclxuICAgIGxldCBjb3B5O1xyXG4gICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoZGF0YSk7XHJcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICBjb3B5ID0gbmV3IERhdGUoZGF0YSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgU2V0KSB7XHJcbiAgICAgICAgY29weSA9IG5ldyBTZXQoZGF0YSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghKGlzV2ViICYmIChkYXRhIGluc3RhbmNlb2YgQmxvYiB8fCBkYXRhIGluc3RhbmNlb2YgRmlsZUxpc3QpKSAmJlxyXG4gICAgICAgIChpc0FycmF5IHx8IGlzT2JqZWN0KGRhdGEpKSkge1xyXG4gICAgICAgIGNvcHkgPSBpc0FycmF5ID8gW10gOiB7fTtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkgJiYgIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcclxuICAgICAgICAgICAgY29weSA9IGRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBjb3B5W2tleV0gPSBjbG9uZU9iamVjdChkYXRhW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29weTtcclxufVxuXG52YXIgY29tcGFjdCA9ICh2YWx1ZSkgPT4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5maWx0ZXIoQm9vbGVhbikgOiBbXTtcblxudmFyIGlzVW5kZWZpbmVkID0gKHZhbCkgPT4gdmFsID09PSB1bmRlZmluZWQ7XG5cbnZhciBnZXQgPSAob2JqLCBwYXRoLCBkZWZhdWx0VmFsdWUpID0+IHtcclxuICAgIGlmICghcGF0aCB8fCAhaXNPYmplY3Qob2JqKSkge1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXN1bHQgPSBjb21wYWN0KHBhdGguc3BsaXQoL1ssW1xcXS5dKz8vKSkucmVkdWNlKChyZXN1bHQsIGtleSkgPT4gaXNOdWxsT3JVbmRlZmluZWQocmVzdWx0KSA/IHJlc3VsdCA6IHJlc3VsdFtrZXldLCBvYmopO1xyXG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKHJlc3VsdCkgfHwgcmVzdWx0ID09PSBvYmpcclxuICAgICAgICA/IGlzVW5kZWZpbmVkKG9ialtwYXRoXSlcclxuICAgICAgICAgICAgPyBkZWZhdWx0VmFsdWVcclxuICAgICAgICAgICAgOiBvYmpbcGF0aF1cclxuICAgICAgICA6IHJlc3VsdDtcclxufTtcblxuY29uc3QgRVZFTlRTID0ge1xyXG4gICAgQkxVUjogJ2JsdXInLFxyXG4gICAgRk9DVVNfT1VUOiAnZm9jdXNvdXQnLFxyXG4gICAgQ0hBTkdFOiAnY2hhbmdlJyxcclxufTtcclxuY29uc3QgVkFMSURBVElPTl9NT0RFID0ge1xyXG4gICAgb25CbHVyOiAnb25CbHVyJyxcclxuICAgIG9uQ2hhbmdlOiAnb25DaGFuZ2UnLFxyXG4gICAgb25TdWJtaXQ6ICdvblN1Ym1pdCcsXHJcbiAgICBvblRvdWNoZWQ6ICdvblRvdWNoZWQnLFxyXG4gICAgYWxsOiAnYWxsJyxcclxufTtcclxuY29uc3QgSU5QVVRfVkFMSURBVElPTl9SVUxFUyA9IHtcclxuICAgIG1heDogJ21heCcsXHJcbiAgICBtaW46ICdtaW4nLFxyXG4gICAgbWF4TGVuZ3RoOiAnbWF4TGVuZ3RoJyxcclxuICAgIG1pbkxlbmd0aDogJ21pbkxlbmd0aCcsXHJcbiAgICBwYXR0ZXJuOiAncGF0dGVybicsXHJcbiAgICByZXF1aXJlZDogJ3JlcXVpcmVkJyxcclxuICAgIHZhbGlkYXRlOiAndmFsaWRhdGUnLFxyXG59O1xuXG5jb25zdCBIb29rRm9ybUNvbnRleHQgPSBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlQ29udGV4dChudWxsKTtcclxuLyoqXHJcbiAqIFRoaXMgY3VzdG9tIGhvb2sgYWxsb3dzIHlvdSB0byBhY2Nlc3MgdGhlIGZvcm0gY29udGV4dC4gdXNlRm9ybUNvbnRleHQgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbiBkZWVwbHkgbmVzdGVkIHN0cnVjdHVyZXMsIHdoZXJlIGl0IHdvdWxkIGJlY29tZSBpbmNvbnZlbmllbnQgdG8gcGFzcyB0aGUgY29udGV4dCBhcyBhIHByb3AuIFRvIGJlIHVzZWQgd2l0aCB7QGxpbmsgRm9ybVByb3ZpZGVyfS5cclxuICpcclxuICogQHJlbWFya3NcclxuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2FwaS91c2Vmb3JtY29udGV4dCkg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvcmVhY3QtaG9vay1mb3JtLXY3LWZvcm0tY29udGV4dC15dHVkaSlcclxuICpcclxuICogQHJldHVybnMgcmV0dXJuIGFsbCB1c2VGb3JtIG1ldGhvZHNcclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgdHN4XHJcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcclxuICogICBjb25zdCBtZXRob2RzID0gdXNlRm9ybSgpO1xyXG4gKiAgIGNvbnN0IG9uU3VibWl0ID0gZGF0YSA9PiBjb25zb2xlLmxvZyhkYXRhKTtcclxuICpcclxuICogICByZXR1cm4gKFxyXG4gKiAgICAgPEZvcm1Qcm92aWRlciB7Li4ubWV0aG9kc30gPlxyXG4gKiAgICAgICA8Zm9ybSBvblN1Ym1pdD17bWV0aG9kcy5oYW5kbGVTdWJtaXQob25TdWJtaXQpfT5cclxuICogICAgICAgICA8TmVzdGVkSW5wdXQgLz5cclxuICogICAgICAgICA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiIC8+XHJcbiAqICAgICAgIDwvZm9ybT5cclxuICogICAgIDwvRm9ybVByb3ZpZGVyPlxyXG4gKiAgICk7XHJcbiAqIH1cclxuICpcclxuICogIGZ1bmN0aW9uIE5lc3RlZElucHV0KCkge1xyXG4gKiAgIGNvbnN0IHsgcmVnaXN0ZXIgfSA9IHVzZUZvcm1Db250ZXh0KCk7IC8vIHJldHJpZXZlIGFsbCBob29rIG1ldGhvZHNcclxuICogICByZXR1cm4gPGlucHV0IHsuLi5yZWdpc3RlcihcInRlc3RcIil9IC8+O1xyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuY29uc3QgdXNlRm9ybUNvbnRleHQgPSAoKSA9PiBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0udXNlQ29udGV4dChIb29rRm9ybUNvbnRleHQpO1xyXG5cbnZhciBnZXRQcm94eUZvcm1TdGF0ZSA9IChmb3JtU3RhdGUsIGNvbnRyb2wsIGxvY2FsUHJveHlGb3JtU3RhdGUsIGlzUm9vdCA9IHRydWUpID0+IHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHtcclxuICAgICAgICBkZWZhdWx0VmFsdWVzOiBjb250cm9sLl9kZWZhdWx0VmFsdWVzLFxyXG4gICAgfTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGZvcm1TdGF0ZSkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIGtleSwge1xyXG4gICAgICAgICAgICBnZXQ6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IF9rZXkgPSBrZXk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbC5fcHJveHlGb3JtU3RhdGVbX2tleV0gIT09IFZBTElEQVRJT05fTU9ERS5hbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sLl9wcm94eUZvcm1TdGF0ZVtfa2V5XSA9ICFpc1Jvb3QgfHwgVkFMSURBVElPTl9NT0RFLmFsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxvY2FsUHJveHlGb3JtU3RhdGUgJiYgKGxvY2FsUHJveHlGb3JtU3RhdGVbX2tleV0gPSB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtU3RhdGVbX2tleV07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xuXG52YXIgaXNFbXB0eU9iamVjdCA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpICYmICFPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoO1xuXG52YXIgc2hvdWxkUmVuZGVyRm9ybVN0YXRlID0gKGZvcm1TdGF0ZURhdGEsIF9wcm94eUZvcm1TdGF0ZSwgdXBkYXRlRm9ybVN0YXRlLCBpc1Jvb3QpID0+IHtcclxuICAgIHVwZGF0ZUZvcm1TdGF0ZShmb3JtU3RhdGVEYXRhKTtcclxuICAgIGNvbnN0IHsgbmFtZSwgLi4uZm9ybVN0YXRlIH0gPSBmb3JtU3RhdGVEYXRhO1xyXG4gICAgcmV0dXJuIChpc0VtcHR5T2JqZWN0KGZvcm1TdGF0ZSkgfHxcclxuICAgICAgICBPYmplY3Qua2V5cyhmb3JtU3RhdGUpLmxlbmd0aCA+PSBPYmplY3Qua2V5cyhfcHJveHlGb3JtU3RhdGUpLmxlbmd0aCB8fFxyXG4gICAgICAgIE9iamVjdC5rZXlzKGZvcm1TdGF0ZSkuZmluZCgoa2V5KSA9PiBfcHJveHlGb3JtU3RhdGVba2V5XSA9PT1cclxuICAgICAgICAgICAgKCFpc1Jvb3QgfHwgVkFMSURBVElPTl9NT0RFLmFsbCkpKTtcclxufTtcblxudmFyIGNvbnZlcnRUb0FycmF5UGF5bG9hZCA9ICh2YWx1ZSkgPT4gKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdKTtcblxudmFyIHNob3VsZFN1YnNjcmliZUJ5TmFtZSA9IChuYW1lLCBzaWduYWxOYW1lLCBleGFjdCkgPT4gZXhhY3QgJiYgc2lnbmFsTmFtZVxyXG4gICAgPyBuYW1lID09PSBzaWduYWxOYW1lXHJcbiAgICA6ICFuYW1lIHx8XHJcbiAgICAgICAgIXNpZ25hbE5hbWUgfHxcclxuICAgICAgICBuYW1lID09PSBzaWduYWxOYW1lIHx8XHJcbiAgICAgICAgY29udmVydFRvQXJyYXlQYXlsb2FkKG5hbWUpLnNvbWUoKGN1cnJlbnROYW1lKSA9PiBjdXJyZW50TmFtZSAmJlxyXG4gICAgICAgICAgICAoY3VycmVudE5hbWUuc3RhcnRzV2l0aChzaWduYWxOYW1lKSB8fFxyXG4gICAgICAgICAgICAgICAgc2lnbmFsTmFtZS5zdGFydHNXaXRoKGN1cnJlbnROYW1lKSkpO1xuXG5mdW5jdGlvbiB1c2VTdWJzY3JpYmUocHJvcHMpIHtcclxuICAgIGNvbnN0IF9wcm9wcyA9IFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS51c2VSZWYocHJvcHMpO1xyXG4gICAgX3Byb3BzLmN1cnJlbnQgPSBwcm9wcztcclxuICAgIFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9ICFwcm9wcy5kaXNhYmxlZCAmJlxyXG4gICAgICAgICAgICBfcHJvcHMuY3VycmVudC5zdWJqZWN0ICYmXHJcbiAgICAgICAgICAgIF9wcm9wcy5jdXJyZW50LnN1YmplY3Quc3Vic2NyaWJlKHtcclxuICAgICAgICAgICAgICAgIG5leHQ6IF9wcm9wcy5jdXJyZW50Lm5leHQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiAmJiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW3Byb3BzLmRpc2FibGVkXSk7XHJcbn1cblxuLyoqXHJcbiAqIFRoaXMgY3VzdG9tIGhvb2sgYWxsb3dzIHlvdSB0byBzdWJzY3JpYmUgdG8gZWFjaCBmb3JtIHN0YXRlLCBhbmQgaXNvbGF0ZSB0aGUgcmUtcmVuZGVyIGF0IHRoZSBjdXN0b20gaG9vayBsZXZlbC4gSXQgaGFzIGl0cyBzY29wZSBpbiB0ZXJtcyBvZiBmb3JtIHN0YXRlIHN1YnNjcmlwdGlvbiwgc28gaXQgd291bGQgbm90IGFmZmVjdCBvdGhlciB1c2VGb3JtU3RhdGUgYW5kIHVzZUZvcm0uIFVzaW5nIHRoaXMgaG9vayBjYW4gcmVkdWNlIHRoZSByZS1yZW5kZXIgaW1wYWN0IG9uIGxhcmdlIGFuZCBjb21wbGV4IGZvcm0gYXBwbGljYXRpb24uXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9hcGkvdXNlZm9ybXN0YXRlKSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy91c2Vmb3Jtc3RhdGUtNzV4bHkpXHJcbiAqXHJcbiAqIEBwYXJhbSBwcm9wcyAtIGluY2x1ZGUgb3B0aW9ucyBvbiBzcGVjaWZ5IGZpZWxkcyB0byBzdWJzY3JpYmUuIHtAbGluayBVc2VGb3JtU3RhdGVSZXR1cm59XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHRzeFxyXG4gKiBmdW5jdGlvbiBBcHAoKSB7XHJcbiAqICAgY29uc3QgeyByZWdpc3RlciwgaGFuZGxlU3VibWl0LCBjb250cm9sIH0gPSB1c2VGb3JtKHtcclxuICogICAgIGRlZmF1bHRWYWx1ZXM6IHtcclxuICogICAgIGZpcnN0TmFtZTogXCJmaXJzdE5hbWVcIlxyXG4gKiAgIH19KTtcclxuICogICBjb25zdCB7IGRpcnR5RmllbGRzIH0gPSB1c2VGb3JtU3RhdGUoe1xyXG4gKiAgICAgY29udHJvbFxyXG4gKiAgIH0pO1xyXG4gKiAgIGNvbnN0IG9uU3VibWl0ID0gKGRhdGEpID0+IGNvbnNvbGUubG9nKGRhdGEpO1xyXG4gKlxyXG4gKiAgIHJldHVybiAoXHJcbiAqICAgICA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlU3VibWl0KG9uU3VibWl0KX0+XHJcbiAqICAgICAgIDxpbnB1dCB7Li4ucmVnaXN0ZXIoXCJmaXJzdE5hbWVcIil9IHBsYWNlaG9sZGVyPVwiRmlyc3QgTmFtZVwiIC8+XHJcbiAqICAgICAgIHtkaXJ0eUZpZWxkcy5maXJzdE5hbWUgJiYgPHA+RmllbGQgaXMgZGlydHkuPC9wPn1cclxuICogICAgICAgPGlucHV0IHR5cGU9XCJzdWJtaXRcIiAvPlxyXG4gKiAgICAgPC9mb3JtPlxyXG4gKiAgICk7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VGb3JtU3RhdGUocHJvcHMpIHtcclxuICAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtQ29udGV4dCgpO1xyXG4gICAgY29uc3QgeyBjb250cm9sID0gbWV0aG9kcy5jb250cm9sLCBkaXNhYmxlZCwgbmFtZSwgZXhhY3QgfSA9IHByb3BzIHx8IHt9O1xyXG4gICAgY29uc3QgW2Zvcm1TdGF0ZSwgdXBkYXRlRm9ybVN0YXRlXSA9IFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS51c2VTdGF0ZShjb250cm9sLl9mb3JtU3RhdGUpO1xyXG4gICAgY29uc3QgX21vdW50ZWQgPSBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0udXNlUmVmKHRydWUpO1xyXG4gICAgY29uc3QgX2xvY2FsUHJveHlGb3JtU3RhdGUgPSBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0udXNlUmVmKHtcclxuICAgICAgICBpc0RpcnR5OiBmYWxzZSxcclxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxyXG4gICAgICAgIGRpcnR5RmllbGRzOiBmYWxzZSxcclxuICAgICAgICB0b3VjaGVkRmllbGRzOiBmYWxzZSxcclxuICAgICAgICBpc1ZhbGlkYXRpbmc6IGZhbHNlLFxyXG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxyXG4gICAgICAgIGVycm9yczogZmFsc2UsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IF9uYW1lID0gUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnVzZVJlZihuYW1lKTtcclxuICAgIF9uYW1lLmN1cnJlbnQgPSBuYW1lO1xyXG4gICAgdXNlU3Vic2NyaWJlKHtcclxuICAgICAgICBkaXNhYmxlZCxcclxuICAgICAgICBuZXh0OiAodmFsdWUpID0+IF9tb3VudGVkLmN1cnJlbnQgJiZcclxuICAgICAgICAgICAgc2hvdWxkU3Vic2NyaWJlQnlOYW1lKF9uYW1lLmN1cnJlbnQsIHZhbHVlLm5hbWUsIGV4YWN0KSAmJlxyXG4gICAgICAgICAgICBzaG91bGRSZW5kZXJGb3JtU3RhdGUodmFsdWUsIF9sb2NhbFByb3h5Rm9ybVN0YXRlLmN1cnJlbnQsIGNvbnRyb2wuX3VwZGF0ZUZvcm1TdGF0ZSkgJiZcclxuICAgICAgICAgICAgdXBkYXRlRm9ybVN0YXRlKHtcclxuICAgICAgICAgICAgICAgIC4uLmNvbnRyb2wuX2Zvcm1TdGF0ZSxcclxuICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICBzdWJqZWN0OiBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZSxcclxuICAgIH0pO1xyXG4gICAgUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgX21vdW50ZWQuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgY29uc3QgaXNEaXJ0eSA9IGNvbnRyb2wuX3Byb3h5Rm9ybVN0YXRlLmlzRGlydHkgJiYgY29udHJvbC5fZ2V0RGlydHkoKTtcclxuICAgICAgICBpZiAoaXNEaXJ0eSAhPT0gY29udHJvbC5fZm9ybVN0YXRlLmlzRGlydHkpIHtcclxuICAgICAgICAgICAgY29udHJvbC5fc3ViamVjdHMuc3RhdGUubmV4dCh7XHJcbiAgICAgICAgICAgICAgICBpc0RpcnR5LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2xvY2FsUHJveHlGb3JtU3RhdGUuY3VycmVudC5pc1ZhbGlkICYmIGNvbnRyb2wuX3VwZGF0ZVZhbGlkKHRydWUpO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIF9tb3VudGVkLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW2NvbnRyb2xdKTtcclxuICAgIHJldHVybiBnZXRQcm94eUZvcm1TdGF0ZShmb3JtU3RhdGUsIGNvbnRyb2wsIF9sb2NhbFByb3h5Rm9ybVN0YXRlLmN1cnJlbnQsIGZhbHNlKTtcclxufVxuXG52YXIgaXNTdHJpbmcgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG5cbnZhciBnZW5lcmF0ZVdhdGNoT3V0cHV0ID0gKG5hbWVzLCBfbmFtZXMsIGZvcm1WYWx1ZXMsIGlzR2xvYmFsLCBkZWZhdWx0VmFsdWUpID0+IHtcclxuICAgIGlmIChpc1N0cmluZyhuYW1lcykpIHtcclxuICAgICAgICBpc0dsb2JhbCAmJiBfbmFtZXMud2F0Y2guYWRkKG5hbWVzKTtcclxuICAgICAgICByZXR1cm4gZ2V0KGZvcm1WYWx1ZXMsIG5hbWVzLCBkZWZhdWx0VmFsdWUpO1xyXG4gICAgfVxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZXMpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5hbWVzLm1hcCgoZmllbGROYW1lKSA9PiAoaXNHbG9iYWwgJiYgX25hbWVzLndhdGNoLmFkZChmaWVsZE5hbWUpLCBnZXQoZm9ybVZhbHVlcywgZmllbGROYW1lKSkpO1xyXG4gICAgfVxyXG4gICAgaXNHbG9iYWwgJiYgKF9uYW1lcy53YXRjaEFsbCA9IHRydWUpO1xyXG4gICAgcmV0dXJuIGZvcm1WYWx1ZXM7XHJcbn07XG5cbi8qKlxyXG4gKiBDdXN0b20gaG9vayB0byBzdWJzY3JpYmUgdG8gZmllbGQgY2hhbmdlIGFuZCBpc29sYXRlIHJlLXJlbmRlcmluZyBhdCB0aGUgY29tcG9uZW50IGxldmVsLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKlxyXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vYXBpL3VzZXdhdGNoKSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tdjctdHMtdXNld2F0Y2gtaDlpNWUpXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHRzeFxyXG4gKiBjb25zdCB7IHdhdGNoIH0gPSB1c2VGb3JtKCk7XHJcbiAqIGNvbnN0IHZhbHVlcyA9IHVzZVdhdGNoKHtcclxuICogICBuYW1lOiBcImZpZWxkTmFtZVwiXHJcbiAqICAgY29udHJvbCxcclxuICogfSlcclxuICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VXYXRjaChwcm9wcykge1xyXG4gICAgY29uc3QgbWV0aG9kcyA9IHVzZUZvcm1Db250ZXh0KCk7XHJcbiAgICBjb25zdCB7IGNvbnRyb2wgPSBtZXRob2RzLmNvbnRyb2wsIG5hbWUsIGRlZmF1bHRWYWx1ZSwgZGlzYWJsZWQsIGV4YWN0LCB9ID0gcHJvcHMgfHwge307XHJcbiAgICBjb25zdCBfbmFtZSA9IFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS51c2VSZWYobmFtZSk7XHJcbiAgICBfbmFtZS5jdXJyZW50ID0gbmFtZTtcclxuICAgIHVzZVN1YnNjcmliZSh7XHJcbiAgICAgICAgZGlzYWJsZWQsXHJcbiAgICAgICAgc3ViamVjdDogY29udHJvbC5fc3ViamVjdHMudmFsdWVzLFxyXG4gICAgICAgIG5leHQ6IChmb3JtU3RhdGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHNob3VsZFN1YnNjcmliZUJ5TmFtZShfbmFtZS5jdXJyZW50LCBmb3JtU3RhdGUubmFtZSwgZXhhY3QpKSB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVWYWx1ZShjbG9uZU9iamVjdChnZW5lcmF0ZVdhdGNoT3V0cHV0KF9uYW1lLmN1cnJlbnQsIGNvbnRyb2wuX25hbWVzLCBmb3JtU3RhdGUudmFsdWVzIHx8IGNvbnRyb2wuX2Zvcm1WYWx1ZXMsIGZhbHNlLCBkZWZhdWx0VmFsdWUpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBbdmFsdWUsIHVwZGF0ZVZhbHVlXSA9IFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS51c2VTdGF0ZShjb250cm9sLl9nZXRXYXRjaChuYW1lLCBkZWZhdWx0VmFsdWUpKTtcclxuICAgIFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS51c2VFZmZlY3QoKCkgPT4gY29udHJvbC5fcmVtb3ZlVW5tb3VudGVkKCkpO1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XG5cbnZhciBpc0tleSA9ICh2YWx1ZSkgPT4gL15cXHcqJC8udGVzdCh2YWx1ZSk7XG5cbnZhciBzdHJpbmdUb1BhdGggPSAoaW5wdXQpID0+IGNvbXBhY3QoaW5wdXQucmVwbGFjZSgvW1wifCddfFxcXS9nLCAnJykuc3BsaXQoL1xcLnxcXFsvKSk7XG5cbmZ1bmN0aW9uIHNldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XHJcbiAgICBsZXQgaW5kZXggPSAtMTtcclxuICAgIGNvbnN0IHRlbXBQYXRoID0gaXNLZXkocGF0aCkgPyBbcGF0aF0gOiBzdHJpbmdUb1BhdGgocGF0aCk7XHJcbiAgICBjb25zdCBsZW5ndGggPSB0ZW1wUGF0aC5sZW5ndGg7XHJcbiAgICBjb25zdCBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xyXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSB0ZW1wUGF0aFtpbmRleF07XHJcbiAgICAgICAgbGV0IG5ld1ZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKGluZGV4ICE9PSBsYXN0SW5kZXgpIHtcclxuICAgICAgICAgICAgY29uc3Qgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcclxuICAgICAgICAgICAgbmV3VmFsdWUgPVxyXG4gICAgICAgICAgICAgICAgaXNPYmplY3Qob2JqVmFsdWUpIHx8IEFycmF5LmlzQXJyYXkob2JqVmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgPyBvYmpWYWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIDogIWlzTmFOKCt0ZW1wUGF0aFtpbmRleCArIDFdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDoge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9iamVjdFtrZXldID0gbmV3VmFsdWU7XHJcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2JqZWN0O1xyXG59XG5cbnZhciBhcHBlbmRFcnJvcnMgPSAobmFtZSwgdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhLCBlcnJvcnMsIHR5cGUsIG1lc3NhZ2UpID0+IHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYVxyXG4gICAgPyB7XHJcbiAgICAgICAgLi4uZXJyb3JzW25hbWVdLFxyXG4gICAgICAgIHR5cGVzOiB7XHJcbiAgICAgICAgICAgIC4uLihlcnJvcnNbbmFtZV0gJiYgZXJyb3JzW25hbWVdLnR5cGVzID8gZXJyb3JzW25hbWVdLnR5cGVzIDoge30pLFxyXG4gICAgICAgICAgICBbdHlwZV06IG1lc3NhZ2UgfHwgdHJ1ZSxcclxuICAgICAgICB9LFxyXG4gICAgfVxyXG4gICAgOiB7fTtcblxuY29uc3QgZm9jdXNGaWVsZEJ5ID0gKGZpZWxkcywgY2FsbGJhY2ssIGZpZWxkc05hbWVzKSA9PiB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBmaWVsZHNOYW1lcyB8fCBPYmplY3Qua2V5cyhmaWVsZHMpKSB7XHJcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoZmllbGRzLCBrZXkpO1xyXG4gICAgICAgIGlmIChmaWVsZCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IF9mLCAuLi5jdXJyZW50RmllbGQgfSA9IGZpZWxkO1xyXG4gICAgICAgICAgICBpZiAoX2YgJiYgY2FsbGJhY2soX2YubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfZi5yZWYuZm9jdXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBfZi5yZWYuZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9mLnJlZnMgJiYgX2YucmVmc1swXS5mb2N1cykge1xyXG4gICAgICAgICAgICAgICAgICAgIF9mLnJlZnNbMF0uZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc09iamVjdChjdXJyZW50RmllbGQpKSB7XHJcbiAgICAgICAgICAgICAgICBmb2N1c0ZpZWxkQnkoY3VycmVudEZpZWxkLCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XG5cbnZhciBnZXRWYWxpZGF0aW9uTW9kZXMgPSAobW9kZSkgPT4gKHtcclxuICAgIGlzT25TdWJtaXQ6ICFtb2RlIHx8IG1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5vblN1Ym1pdCxcclxuICAgIGlzT25CbHVyOiBtb2RlID09PSBWQUxJREFUSU9OX01PREUub25CbHVyLFxyXG4gICAgaXNPbkNoYW5nZTogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLm9uQ2hhbmdlLFxyXG4gICAgaXNPbkFsbDogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLmFsbCxcclxuICAgIGlzT25Ub3VjaDogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLm9uVG91Y2hlZCxcclxufSk7XG5cbnZhciBpc1dhdGNoZWQgPSAobmFtZSwgX25hbWVzLCBpc0JsdXJFdmVudCkgPT4gIWlzQmx1ckV2ZW50ICYmXHJcbiAgICAoX25hbWVzLndhdGNoQWxsIHx8XHJcbiAgICAgICAgX25hbWVzLndhdGNoLmhhcyhuYW1lKSB8fFxyXG4gICAgICAgIFsuLi5fbmFtZXMud2F0Y2hdLnNvbWUoKHdhdGNoTmFtZSkgPT4gbmFtZS5zdGFydHNXaXRoKHdhdGNoTmFtZSkgJiZcclxuICAgICAgICAgICAgL15cXC5cXHcrLy50ZXN0KG5hbWUuc2xpY2Uod2F0Y2hOYW1lLmxlbmd0aCkpKSk7XG5cbnZhciB1cGRhdGVGaWVsZEFycmF5Um9vdEVycm9yID0gKGVycm9ycywgZXJyb3IsIG5hbWUpID0+IHtcclxuICAgIGNvbnN0IGZpZWxkQXJyYXlFcnJvcnMgPSBjb21wYWN0KGdldChlcnJvcnMsIG5hbWUpKTtcclxuICAgIHNldChmaWVsZEFycmF5RXJyb3JzLCAncm9vdCcsIGVycm9yW25hbWVdKTtcclxuICAgIHNldChlcnJvcnMsIG5hbWUsIGZpZWxkQXJyYXlFcnJvcnMpO1xyXG4gICAgcmV0dXJuIGVycm9ycztcclxufTtcblxudmFyIGlzQm9vbGVhbiA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG5cbnZhciBpc0ZpbGVJbnB1dCA9IChlbGVtZW50KSA9PiBlbGVtZW50LnR5cGUgPT09ICdmaWxlJztcblxudmFyIGlzRnVuY3Rpb24gPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIGlzSFRNTEVsZW1lbnQgPSAodmFsdWUpID0+IHtcclxuICAgIGlmICghaXNXZWIpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvd25lciA9IHZhbHVlID8gdmFsdWUub3duZXJEb2N1bWVudCA6IDA7XHJcbiAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2ZcclxuICAgICAgICAob3duZXIgJiYgb3duZXIuZGVmYXVsdFZpZXcgPyBvd25lci5kZWZhdWx0Vmlldy5IVE1MRWxlbWVudCA6IEhUTUxFbGVtZW50KSk7XHJcbn07XG5cbnZhciBpc01lc3NhZ2UgPSAodmFsdWUpID0+IGlzU3RyaW5nKHZhbHVlKTtcblxudmFyIGlzUmFkaW9JbnB1dCA9IChlbGVtZW50KSA9PiBlbGVtZW50LnR5cGUgPT09ICdyYWRpbyc7XG5cbnZhciBpc1JlZ2V4ID0gKHZhbHVlKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cDtcblxuY29uc3QgZGVmYXVsdFJlc3VsdCA9IHtcclxuICAgIHZhbHVlOiBmYWxzZSxcclxuICAgIGlzVmFsaWQ6IGZhbHNlLFxyXG59O1xyXG5jb25zdCB2YWxpZFJlc3VsdCA9IHsgdmFsdWU6IHRydWUsIGlzVmFsaWQ6IHRydWUgfTtcclxudmFyIGdldENoZWNrYm94VmFsdWUgPSAob3B0aW9ucykgPT4ge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IG9wdGlvbnNcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKG9wdGlvbikgPT4gb3B0aW9uICYmIG9wdGlvbi5jaGVja2VkICYmICFvcHRpb24uZGlzYWJsZWQpXHJcbiAgICAgICAgICAgICAgICAubWFwKChvcHRpb24pID0+IG9wdGlvbi52YWx1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZXMsIGlzVmFsaWQ6ICEhdmFsdWVzLmxlbmd0aCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0aW9uc1swXS5jaGVja2VkICYmICFvcHRpb25zWzBdLmRpc2FibGVkXHJcbiAgICAgICAgICAgID8gLy8gQHRzLWV4cGVjdC1lcnJvciBleHBlY3RlZCB0byB3b3JrIGluIHRoZSBicm93c2VyXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zWzBdLmF0dHJpYnV0ZXMgJiYgIWlzVW5kZWZpbmVkKG9wdGlvbnNbMF0uYXR0cmlidXRlcy52YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICA/IGlzVW5kZWZpbmVkKG9wdGlvbnNbMF0udmFsdWUpIHx8IG9wdGlvbnNbMF0udmFsdWUgPT09ICcnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdmFsaWRSZXN1bHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7IHZhbHVlOiBvcHRpb25zWzBdLnZhbHVlLCBpc1ZhbGlkOiB0cnVlIH1cclxuICAgICAgICAgICAgICAgICAgICA6IHZhbGlkUmVzdWx0XHJcbiAgICAgICAgICAgIDogZGVmYXVsdFJlc3VsdDtcclxuICAgIH1cclxuICAgIHJldHVybiBkZWZhdWx0UmVzdWx0O1xyXG59O1xuXG5jb25zdCBkZWZhdWx0UmV0dXJuID0ge1xyXG4gICAgaXNWYWxpZDogZmFsc2UsXHJcbiAgICB2YWx1ZTogbnVsbCxcclxufTtcclxudmFyIGdldFJhZGlvVmFsdWUgPSAob3B0aW9ucykgPT4gQXJyYXkuaXNBcnJheShvcHRpb25zKVxyXG4gICAgPyBvcHRpb25zLnJlZHVjZSgocHJldmlvdXMsIG9wdGlvbikgPT4gb3B0aW9uICYmIG9wdGlvbi5jaGVja2VkICYmICFvcHRpb24uZGlzYWJsZWRcclxuICAgICAgICA/IHtcclxuICAgICAgICAgICAgaXNWYWxpZDogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IG9wdGlvbi52YWx1ZSxcclxuICAgICAgICB9XHJcbiAgICAgICAgOiBwcmV2aW91cywgZGVmYXVsdFJldHVybilcclxuICAgIDogZGVmYXVsdFJldHVybjtcblxuZnVuY3Rpb24gZ2V0VmFsaWRhdGVFcnJvcihyZXN1bHQsIHJlZiwgdHlwZSA9ICd2YWxpZGF0ZScpIHtcclxuICAgIGlmIChpc01lc3NhZ2UocmVzdWx0KSB8fFxyXG4gICAgICAgIChBcnJheS5pc0FycmF5KHJlc3VsdCkgJiYgcmVzdWx0LmV2ZXJ5KGlzTWVzc2FnZSkpIHx8XHJcbiAgICAgICAgKGlzQm9vbGVhbihyZXN1bHQpICYmICFyZXN1bHQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgbWVzc2FnZTogaXNNZXNzYWdlKHJlc3VsdCkgPyByZXN1bHQgOiAnJyxcclxuICAgICAgICAgICAgcmVmLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cblxudmFyIGdldFZhbHVlQW5kTWVzc2FnZSA9ICh2YWxpZGF0aW9uRGF0YSkgPT4gaXNPYmplY3QodmFsaWRhdGlvbkRhdGEpICYmICFpc1JlZ2V4KHZhbGlkYXRpb25EYXRhKVxyXG4gICAgPyB2YWxpZGF0aW9uRGF0YVxyXG4gICAgOiB7XHJcbiAgICAgICAgdmFsdWU6IHZhbGlkYXRpb25EYXRhLFxyXG4gICAgICAgIG1lc3NhZ2U6ICcnLFxyXG4gICAgfTtcblxudmFyIHZhbGlkYXRlRmllbGQgPSBhc3luYyAoZmllbGQsIGZvcm1WYWx1ZXMsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiwgaXNGaWVsZEFycmF5KSA9PiB7XHJcbiAgICBjb25zdCB7IHJlZiwgcmVmcywgcmVxdWlyZWQsIG1heExlbmd0aCwgbWluTGVuZ3RoLCBtaW4sIG1heCwgcGF0dGVybiwgdmFsaWRhdGUsIG5hbWUsIHZhbHVlQXNOdW1iZXIsIG1vdW50LCBkaXNhYmxlZCwgfSA9IGZpZWxkLl9mO1xyXG4gICAgY29uc3QgaW5wdXRWYWx1ZSA9IGdldChmb3JtVmFsdWVzLCBuYW1lKTtcclxuICAgIGlmICghbW91bnQgfHwgZGlzYWJsZWQpIHtcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbnB1dFJlZiA9IHJlZnMgPyByZWZzWzBdIDogcmVmO1xyXG4gICAgY29uc3Qgc2V0Q3VzdG9tVmFsaWRpdHkgPSAobWVzc2FnZSkgPT4ge1xyXG4gICAgICAgIGlmIChzaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uICYmIGlucHV0UmVmLnJlcG9ydFZhbGlkaXR5KSB7XHJcbiAgICAgICAgICAgIGlucHV0UmVmLnNldEN1c3RvbVZhbGlkaXR5KGlzQm9vbGVhbihtZXNzYWdlKSA/ICcnIDogbWVzc2FnZSB8fCAnJyk7XHJcbiAgICAgICAgICAgIGlucHV0UmVmLnJlcG9ydFZhbGlkaXR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IGVycm9yID0ge307XHJcbiAgICBjb25zdCBpc1JhZGlvID0gaXNSYWRpb0lucHV0KHJlZik7XHJcbiAgICBjb25zdCBpc0NoZWNrQm94ID0gaXNDaGVja0JveElucHV0KHJlZik7XHJcbiAgICBjb25zdCBpc1JhZGlvT3JDaGVja2JveCA9IGlzUmFkaW8gfHwgaXNDaGVja0JveDtcclxuICAgIGNvbnN0IGlzRW1wdHkgPSAoKHZhbHVlQXNOdW1iZXIgfHwgaXNGaWxlSW5wdXQocmVmKSkgJiZcclxuICAgICAgICBpc1VuZGVmaW5lZChyZWYudmFsdWUpICYmXHJcbiAgICAgICAgaXNVbmRlZmluZWQoaW5wdXRWYWx1ZSkpIHx8XHJcbiAgICAgICAgKGlzSFRNTEVsZW1lbnQocmVmKSAmJiByZWYudmFsdWUgPT09ICcnKSB8fFxyXG4gICAgICAgIGlucHV0VmFsdWUgPT09ICcnIHx8XHJcbiAgICAgICAgKEFycmF5LmlzQXJyYXkoaW5wdXRWYWx1ZSkgJiYgIWlucHV0VmFsdWUubGVuZ3RoKTtcclxuICAgIGNvbnN0IGFwcGVuZEVycm9yc0N1cnJ5ID0gYXBwZW5kRXJyb3JzLmJpbmQobnVsbCwgbmFtZSwgdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhLCBlcnJvcik7XHJcbiAgICBjb25zdCBnZXRNaW5NYXhNZXNzYWdlID0gKGV4Y2VlZE1heCwgbWF4TGVuZ3RoTWVzc2FnZSwgbWluTGVuZ3RoTWVzc2FnZSwgbWF4VHlwZSA9IElOUFVUX1ZBTElEQVRJT05fUlVMRVMubWF4TGVuZ3RoLCBtaW5UeXBlID0gSU5QVVRfVkFMSURBVElPTl9SVUxFUy5taW5MZW5ndGgpID0+IHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gZXhjZWVkTWF4ID8gbWF4TGVuZ3RoTWVzc2FnZSA6IG1pbkxlbmd0aE1lc3NhZ2U7XHJcbiAgICAgICAgZXJyb3JbbmFtZV0gPSB7XHJcbiAgICAgICAgICAgIHR5cGU6IGV4Y2VlZE1heCA/IG1heFR5cGUgOiBtaW5UeXBlLFxyXG4gICAgICAgICAgICBtZXNzYWdlLFxyXG4gICAgICAgICAgICByZWYsXHJcbiAgICAgICAgICAgIC4uLmFwcGVuZEVycm9yc0N1cnJ5KGV4Y2VlZE1heCA/IG1heFR5cGUgOiBtaW5UeXBlLCBtZXNzYWdlKSxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIGlmIChpc0ZpZWxkQXJyYXlcclxuICAgICAgICA/ICFBcnJheS5pc0FycmF5KGlucHV0VmFsdWUpIHx8ICFpbnB1dFZhbHVlLmxlbmd0aFxyXG4gICAgICAgIDogcmVxdWlyZWQgJiZcclxuICAgICAgICAgICAgKCghaXNSYWRpb09yQ2hlY2tib3ggJiYgKGlzRW1wdHkgfHwgaXNOdWxsT3JVbmRlZmluZWQoaW5wdXRWYWx1ZSkpKSB8fFxyXG4gICAgICAgICAgICAgICAgKGlzQm9vbGVhbihpbnB1dFZhbHVlKSAmJiAhaW5wdXRWYWx1ZSkgfHxcclxuICAgICAgICAgICAgICAgIChpc0NoZWNrQm94ICYmICFnZXRDaGVja2JveFZhbHVlKHJlZnMpLmlzVmFsaWQpIHx8XHJcbiAgICAgICAgICAgICAgICAoaXNSYWRpbyAmJiAhZ2V0UmFkaW9WYWx1ZShyZWZzKS5pc1ZhbGlkKSkpIHtcclxuICAgICAgICBjb25zdCB7IHZhbHVlLCBtZXNzYWdlIH0gPSBpc01lc3NhZ2UocmVxdWlyZWQpXHJcbiAgICAgICAgICAgID8geyB2YWx1ZTogISFyZXF1aXJlZCwgbWVzc2FnZTogcmVxdWlyZWQgfVxyXG4gICAgICAgICAgICA6IGdldFZhbHVlQW5kTWVzc2FnZShyZXF1aXJlZCk7XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGVycm9yW25hbWVdID0ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogSU5QVVRfVkFMSURBVElPTl9SVUxFUy5yZXF1aXJlZCxcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICByZWY6IGlucHV0UmVmLFxyXG4gICAgICAgICAgICAgICAgLi4uYXBwZW5kRXJyb3JzQ3VycnkoSU5QVVRfVkFMSURBVElPTl9SVUxFUy5yZXF1aXJlZCwgbWVzc2FnZSksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRDdXN0b21WYWxpZGl0eShtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghaXNFbXB0eSAmJiAoIWlzTnVsbE9yVW5kZWZpbmVkKG1pbikgfHwgIWlzTnVsbE9yVW5kZWZpbmVkKG1heCkpKSB7XHJcbiAgICAgICAgbGV0IGV4Y2VlZE1heDtcclxuICAgICAgICBsZXQgZXhjZWVkTWluO1xyXG4gICAgICAgIGNvbnN0IG1heE91dHB1dCA9IGdldFZhbHVlQW5kTWVzc2FnZShtYXgpO1xyXG4gICAgICAgIGNvbnN0IG1pbk91dHB1dCA9IGdldFZhbHVlQW5kTWVzc2FnZShtaW4pO1xyXG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQoaW5wdXRWYWx1ZSkgJiYgIWlzTmFOKGlucHV0VmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlTnVtYmVyID0gcmVmLnZhbHVlQXNOdW1iZXIgfHxcclxuICAgICAgICAgICAgICAgIChpbnB1dFZhbHVlID8gK2lucHV0VmFsdWUgOiBpbnB1dFZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChtYXhPdXRwdXQudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBleGNlZWRNYXggPSB2YWx1ZU51bWJlciA+IG1heE91dHB1dC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKG1pbk91dHB1dC52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGV4Y2VlZE1pbiA9IHZhbHVlTnVtYmVyIDwgbWluT3V0cHV0LnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZURhdGUgPSByZWYudmFsdWVBc0RhdGUgfHwgbmV3IERhdGUoaW5wdXRWYWx1ZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRUaW1lVG9EYXRlID0gKHRpbWUpID0+IG5ldyBEYXRlKG5ldyBEYXRlKCkudG9EYXRlU3RyaW5nKCkgKyAnICcgKyB0aW1lKTtcclxuICAgICAgICAgICAgY29uc3QgaXNUaW1lID0gcmVmLnR5cGUgPT0gJ3RpbWUnO1xyXG4gICAgICAgICAgICBjb25zdCBpc1dlZWsgPSByZWYudHlwZSA9PSAnd2Vlayc7XHJcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhtYXhPdXRwdXQudmFsdWUpICYmIGlucHV0VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGV4Y2VlZE1heCA9IGlzVGltZVxyXG4gICAgICAgICAgICAgICAgICAgID8gY29udmVydFRpbWVUb0RhdGUoaW5wdXRWYWx1ZSkgPiBjb252ZXJ0VGltZVRvRGF0ZShtYXhPdXRwdXQudmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBpc1dlZWtcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBpbnB1dFZhbHVlID4gbWF4T3V0cHV0LnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWVEYXRlID4gbmV3IERhdGUobWF4T3V0cHV0LnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcobWluT3V0cHV0LnZhbHVlKSAmJiBpbnB1dFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBleGNlZWRNaW4gPSBpc1RpbWVcclxuICAgICAgICAgICAgICAgICAgICA/IGNvbnZlcnRUaW1lVG9EYXRlKGlucHV0VmFsdWUpIDwgY29udmVydFRpbWVUb0RhdGUobWluT3V0cHV0LnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgIDogaXNXZWVrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gaW5wdXRWYWx1ZSA8IG1pbk91dHB1dC52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlRGF0ZSA8IG5ldyBEYXRlKG1pbk91dHB1dC52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV4Y2VlZE1heCB8fCBleGNlZWRNaW4pIHtcclxuICAgICAgICAgICAgZ2V0TWluTWF4TWVzc2FnZSghIWV4Y2VlZE1heCwgbWF4T3V0cHV0Lm1lc3NhZ2UsIG1pbk91dHB1dC5tZXNzYWdlLCBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLm1heCwgSU5QVVRfVkFMSURBVElPTl9SVUxFUy5taW4pO1xyXG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xyXG4gICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHkoZXJyb3JbbmFtZV0ubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoKG1heExlbmd0aCB8fCBtaW5MZW5ndGgpICYmXHJcbiAgICAgICAgIWlzRW1wdHkgJiZcclxuICAgICAgICAoaXNTdHJpbmcoaW5wdXRWYWx1ZSkgfHwgKGlzRmllbGRBcnJheSAmJiBBcnJheS5pc0FycmF5KGlucHV0VmFsdWUpKSkpIHtcclxuICAgICAgICBjb25zdCBtYXhMZW5ndGhPdXRwdXQgPSBnZXRWYWx1ZUFuZE1lc3NhZ2UobWF4TGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBtaW5MZW5ndGhPdXRwdXQgPSBnZXRWYWx1ZUFuZE1lc3NhZ2UobWluTGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBleGNlZWRNYXggPSAhaXNOdWxsT3JVbmRlZmluZWQobWF4TGVuZ3RoT3V0cHV0LnZhbHVlKSAmJlxyXG4gICAgICAgICAgICBpbnB1dFZhbHVlLmxlbmd0aCA+IG1heExlbmd0aE91dHB1dC52YWx1ZTtcclxuICAgICAgICBjb25zdCBleGNlZWRNaW4gPSAhaXNOdWxsT3JVbmRlZmluZWQobWluTGVuZ3RoT3V0cHV0LnZhbHVlKSAmJlxyXG4gICAgICAgICAgICBpbnB1dFZhbHVlLmxlbmd0aCA8IG1pbkxlbmd0aE91dHB1dC52YWx1ZTtcclxuICAgICAgICBpZiAoZXhjZWVkTWF4IHx8IGV4Y2VlZE1pbikge1xyXG4gICAgICAgICAgICBnZXRNaW5NYXhNZXNzYWdlKGV4Y2VlZE1heCwgbWF4TGVuZ3RoT3V0cHV0Lm1lc3NhZ2UsIG1pbkxlbmd0aE91dHB1dC5tZXNzYWdlKTtcclxuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcclxuICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KGVycm9yW25hbWVdLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHBhdHRlcm4gJiYgIWlzRW1wdHkgJiYgaXNTdHJpbmcoaW5wdXRWYWx1ZSkpIHtcclxuICAgICAgICBjb25zdCB7IHZhbHVlOiBwYXR0ZXJuVmFsdWUsIG1lc3NhZ2UgfSA9IGdldFZhbHVlQW5kTWVzc2FnZShwYXR0ZXJuKTtcclxuICAgICAgICBpZiAoaXNSZWdleChwYXR0ZXJuVmFsdWUpICYmICFpbnB1dFZhbHVlLm1hdGNoKHBhdHRlcm5WYWx1ZSkpIHtcclxuICAgICAgICAgICAgZXJyb3JbbmFtZV0gPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnBhdHRlcm4sXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgcmVmLFxyXG4gICAgICAgICAgICAgICAgLi4uYXBwZW5kRXJyb3JzQ3VycnkoSU5QVVRfVkFMSURBVElPTl9SVUxFUy5wYXR0ZXJuLCBtZXNzYWdlKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcclxuICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHZhbGlkYXRlKSB7XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsaWRhdGUpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlKGlucHV0VmFsdWUsIGZvcm1WYWx1ZXMpO1xyXG4gICAgICAgICAgICBjb25zdCB2YWxpZGF0ZUVycm9yID0gZ2V0VmFsaWRhdGVFcnJvcihyZXN1bHQsIGlucHV0UmVmKTtcclxuICAgICAgICAgICAgaWYgKHZhbGlkYXRlRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yW25hbWVdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLnZhbGlkYXRlRXJyb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uYXBwZW5kRXJyb3JzQ3VycnkoSU5QVVRfVkFMSURBVElPTl9SVUxFUy52YWxpZGF0ZSwgdmFsaWRhdGVFcnJvci5tZXNzYWdlKSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KHZhbGlkYXRlRXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbGlkYXRlKSkge1xyXG4gICAgICAgICAgICBsZXQgdmFsaWRhdGlvblJlc3VsdCA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWxpZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0VtcHR5T2JqZWN0KHZhbGlkYXRpb25SZXN1bHQpICYmICF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRlRXJyb3IgPSBnZXRWYWxpZGF0ZUVycm9yKGF3YWl0IHZhbGlkYXRlW2tleV0oaW5wdXRWYWx1ZSwgZm9ybVZhbHVlcyksIGlucHV0UmVmLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi52YWxpZGF0ZUVycm9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5hcHBlbmRFcnJvcnNDdXJyeShrZXksIHZhbGlkYXRlRXJyb3IubWVzc2FnZSksXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRDdXN0b21WYWxpZGl0eSh2YWxpZGF0ZUVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JbbmFtZV0gPSB2YWxpZGF0aW9uUmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzRW1wdHlPYmplY3QodmFsaWRhdGlvblJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yW25hbWVdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZjogaW5wdXRSZWYsXHJcbiAgICAgICAgICAgICAgICAgICAgLi4udmFsaWRhdGlvblJlc3VsdCxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldEN1c3RvbVZhbGlkaXR5KHRydWUpO1xyXG4gICAgcmV0dXJuIGVycm9yO1xyXG59O1xuXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgdXBkYXRlUGF0aCkge1xyXG4gICAgY29uc3QgbGVuZ3RoID0gdXBkYXRlUGF0aC5zbGljZSgwLCAtMSkubGVuZ3RoO1xyXG4gICAgbGV0IGluZGV4ID0gMDtcclxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICAgIG9iamVjdCA9IGlzVW5kZWZpbmVkKG9iamVjdCkgPyBpbmRleCsrIDogb2JqZWN0W3VwZGF0ZVBhdGhbaW5kZXgrK11dO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9iamVjdDtcclxufVxyXG5mdW5jdGlvbiBpc0VtcHR5QXJyYXkob2JqKSB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKG9ialtrZXldKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gdW5zZXQob2JqZWN0LCBwYXRoKSB7XHJcbiAgICBjb25zdCBwYXRocyA9IEFycmF5LmlzQXJyYXkocGF0aClcclxuICAgICAgICA/IHBhdGhcclxuICAgICAgICA6IGlzS2V5KHBhdGgpXHJcbiAgICAgICAgICAgID8gW3BhdGhdXHJcbiAgICAgICAgICAgIDogc3RyaW5nVG9QYXRoKHBhdGgpO1xyXG4gICAgY29uc3QgY2hpbGRPYmplY3QgPSBwYXRocy5sZW5ndGggPT09IDEgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgcGF0aHMpO1xyXG4gICAgY29uc3QgaW5kZXggPSBwYXRocy5sZW5ndGggLSAxO1xyXG4gICAgY29uc3Qga2V5ID0gcGF0aHNbaW5kZXhdO1xyXG4gICAgaWYgKGNoaWxkT2JqZWN0KSB7XHJcbiAgICAgICAgZGVsZXRlIGNoaWxkT2JqZWN0W2tleV07XHJcbiAgICB9XHJcbiAgICBpZiAoaW5kZXggIT09IDAgJiZcclxuICAgICAgICAoKGlzT2JqZWN0KGNoaWxkT2JqZWN0KSAmJiBpc0VtcHR5T2JqZWN0KGNoaWxkT2JqZWN0KSkgfHxcclxuICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoY2hpbGRPYmplY3QpICYmIGlzRW1wdHlBcnJheShjaGlsZE9iamVjdCkpKSkge1xyXG4gICAgICAgIHVuc2V0KG9iamVjdCwgcGF0aHMuc2xpY2UoMCwgLTEpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBvYmplY3Q7XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3ViamVjdCgpIHtcclxuICAgIGxldCBfb2JzZXJ2ZXJzID0gW107XHJcbiAgICBjb25zdCBuZXh0ID0gKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCBvYnNlcnZlciBvZiBfb2JzZXJ2ZXJzKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQgJiYgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHN1YnNjcmliZSA9IChvYnNlcnZlcikgPT4ge1xyXG4gICAgICAgIF9vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIF9vYnNlcnZlcnMgPSBfb2JzZXJ2ZXJzLmZpbHRlcigobykgPT4gbyAhPT0gb2JzZXJ2ZXIpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XHJcbiAgICAgICAgX29ic2VydmVycyA9IFtdO1xyXG4gICAgfTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0IG9ic2VydmVycygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9vYnNlcnZlcnM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuZXh0LFxyXG4gICAgICAgIHN1YnNjcmliZSxcclxuICAgICAgICB1bnN1YnNjcmliZSxcclxuICAgIH07XHJcbn1cblxudmFyIGlzUHJpbWl0aXZlID0gKHZhbHVlKSA9PiBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkgfHwgIWlzT2JqZWN0VHlwZSh2YWx1ZSk7XG5cbmZ1bmN0aW9uIGRlZXBFcXVhbChvYmplY3QxLCBvYmplY3QyKSB7XHJcbiAgICBpZiAoaXNQcmltaXRpdmUob2JqZWN0MSkgfHwgaXNQcmltaXRpdmUob2JqZWN0MikpIHtcclxuICAgICAgICByZXR1cm4gb2JqZWN0MSA9PT0gb2JqZWN0MjtcclxuICAgIH1cclxuICAgIGlmIChpc0RhdGVPYmplY3Qob2JqZWN0MSkgJiYgaXNEYXRlT2JqZWN0KG9iamVjdDIpKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iamVjdDEuZ2V0VGltZSgpID09PSBvYmplY3QyLmdldFRpbWUoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGtleXMxID0gT2JqZWN0LmtleXMob2JqZWN0MSk7XHJcbiAgICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9iamVjdDIpO1xyXG4gICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5czEpIHtcclxuICAgICAgICBjb25zdCB2YWwxID0gb2JqZWN0MVtrZXldO1xyXG4gICAgICAgIGlmICgha2V5czIuaW5jbHVkZXMoa2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChrZXkgIT09ICdyZWYnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbDIgPSBvYmplY3QyW2tleV07XHJcbiAgICAgICAgICAgIGlmICgoaXNEYXRlT2JqZWN0KHZhbDEpICYmIGlzRGF0ZU9iamVjdCh2YWwyKSkgfHxcclxuICAgICAgICAgICAgICAgIChpc09iamVjdCh2YWwxKSAmJiBpc09iamVjdCh2YWwyKSkgfHxcclxuICAgICAgICAgICAgICAgIChBcnJheS5pc0FycmF5KHZhbDEpICYmIEFycmF5LmlzQXJyYXkodmFsMikpXHJcbiAgICAgICAgICAgICAgICA/ICFkZWVwRXF1YWwodmFsMSwgdmFsMilcclxuICAgICAgICAgICAgICAgIDogdmFsMSAhPT0gdmFsMikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cblxudmFyIGlzTXVsdGlwbGVTZWxlY3QgPSAoZWxlbWVudCkgPT4gZWxlbWVudC50eXBlID09PSBgc2VsZWN0LW11bHRpcGxlYDtcblxudmFyIGlzUmFkaW9PckNoZWNrYm94ID0gKHJlZikgPT4gaXNSYWRpb0lucHV0KHJlZikgfHwgaXNDaGVja0JveElucHV0KHJlZik7XG5cbnZhciBsaXZlID0gKHJlZikgPT4gaXNIVE1MRWxlbWVudChyZWYpICYmIHJlZi5pc0Nvbm5lY3RlZDtcblxudmFyIG9iamVjdEhhc0Z1bmN0aW9uID0gKGRhdGEpID0+IHtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihkYXRhW2tleV0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufTtcblxuZnVuY3Rpb24gbWFya0ZpZWxkc0RpcnR5KGRhdGEsIGZpZWxkcyA9IHt9KSB7XHJcbiAgICBjb25zdCBpc1BhcmVudE5vZGVBcnJheSA9IEFycmF5LmlzQXJyYXkoZGF0YSk7XHJcbiAgICBpZiAoaXNPYmplY3QoZGF0YSkgfHwgaXNQYXJlbnROb2RlQXJyYXkpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFba2V5XSkgfHxcclxuICAgICAgICAgICAgICAgIChpc09iamVjdChkYXRhW2tleV0pICYmICFvYmplY3RIYXNGdW5jdGlvbihkYXRhW2tleV0pKSkge1xyXG4gICAgICAgICAgICAgICAgZmllbGRzW2tleV0gPSBBcnJheS5pc0FycmF5KGRhdGFba2V5XSkgPyBbXSA6IHt9O1xyXG4gICAgICAgICAgICAgICAgbWFya0ZpZWxkc0RpcnR5KGRhdGFba2V5XSwgZmllbGRzW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc051bGxPclVuZGVmaW5lZChkYXRhW2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICBmaWVsZHNba2V5XSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmllbGRzO1xyXG59XHJcbmZ1bmN0aW9uIGdldERpcnR5RmllbGRzRnJvbURlZmF1bHRWYWx1ZXMoZGF0YSwgZm9ybVZhbHVlcywgZGlydHlGaWVsZHNGcm9tVmFsdWVzKSB7XHJcbiAgICBjb25zdCBpc1BhcmVudE5vZGVBcnJheSA9IEFycmF5LmlzQXJyYXkoZGF0YSk7XHJcbiAgICBpZiAoaXNPYmplY3QoZGF0YSkgfHwgaXNQYXJlbnROb2RlQXJyYXkpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFba2V5XSkgfHxcclxuICAgICAgICAgICAgICAgIChpc09iamVjdChkYXRhW2tleV0pICYmICFvYmplY3RIYXNGdW5jdGlvbihkYXRhW2tleV0pKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGZvcm1WYWx1ZXMpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgaXNQcmltaXRpdmUoZGlydHlGaWVsZHNGcm9tVmFsdWVzW2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlydHlGaWVsZHNGcm9tVmFsdWVzW2tleV0gPSBBcnJheS5pc0FycmF5KGRhdGFba2V5XSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBtYXJrRmllbGRzRGlydHkoZGF0YVtrZXldLCBbXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7IC4uLm1hcmtGaWVsZHNEaXJ0eShkYXRhW2tleV0pIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBnZXREaXJ0eUZpZWxkc0Zyb21EZWZhdWx0VmFsdWVzKGRhdGFba2V5XSwgaXNOdWxsT3JVbmRlZmluZWQoZm9ybVZhbHVlcykgPyB7fSA6IGZvcm1WYWx1ZXNba2V5XSwgZGlydHlGaWVsZHNGcm9tVmFsdWVzW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGlydHlGaWVsZHNGcm9tVmFsdWVzW2tleV0gPSAhZGVlcEVxdWFsKGRhdGFba2V5XSwgZm9ybVZhbHVlc1trZXldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXM7XHJcbn1cclxudmFyIGdldERpcnR5RmllbGRzID0gKGRlZmF1bHRWYWx1ZXMsIGZvcm1WYWx1ZXMpID0+IGdldERpcnR5RmllbGRzRnJvbURlZmF1bHRWYWx1ZXMoZGVmYXVsdFZhbHVlcywgZm9ybVZhbHVlcywgbWFya0ZpZWxkc0RpcnR5KGZvcm1WYWx1ZXMpKTtcblxudmFyIGdldEZpZWxkVmFsdWVBcyA9ICh2YWx1ZSwgeyB2YWx1ZUFzTnVtYmVyLCB2YWx1ZUFzRGF0ZSwgc2V0VmFsdWVBcyB9KSA9PiBpc1VuZGVmaW5lZCh2YWx1ZSlcclxuICAgID8gdmFsdWVcclxuICAgIDogdmFsdWVBc051bWJlclxyXG4gICAgICAgID8gdmFsdWUgPT09ICcnXHJcbiAgICAgICAgICAgID8gTmFOXHJcbiAgICAgICAgICAgIDogdmFsdWVcclxuICAgICAgICAgICAgICAgID8gK3ZhbHVlXHJcbiAgICAgICAgICAgICAgICA6IHZhbHVlXHJcbiAgICAgICAgOiB2YWx1ZUFzRGF0ZSAmJiBpc1N0cmluZyh2YWx1ZSlcclxuICAgICAgICAgICAgPyBuZXcgRGF0ZSh2YWx1ZSlcclxuICAgICAgICAgICAgOiBzZXRWYWx1ZUFzXHJcbiAgICAgICAgICAgICAgICA/IHNldFZhbHVlQXModmFsdWUpXHJcbiAgICAgICAgICAgICAgICA6IHZhbHVlO1xuXG5mdW5jdGlvbiBnZXRGaWVsZFZhbHVlKF9mKSB7XHJcbiAgICBjb25zdCByZWYgPSBfZi5yZWY7XHJcbiAgICBpZiAoX2YucmVmcyA/IF9mLnJlZnMuZXZlcnkoKHJlZikgPT4gcmVmLmRpc2FibGVkKSA6IHJlZi5kaXNhYmxlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChpc0ZpbGVJbnB1dChyZWYpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlZi5maWxlcztcclxuICAgIH1cclxuICAgIGlmIChpc1JhZGlvSW5wdXQocmVmKSkge1xyXG4gICAgICAgIHJldHVybiBnZXRSYWRpb1ZhbHVlKF9mLnJlZnMpLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzTXVsdGlwbGVTZWxlY3QocmVmKSkge1xyXG4gICAgICAgIHJldHVybiBbLi4ucmVmLnNlbGVjdGVkT3B0aW9uc10ubWFwKCh7IHZhbHVlIH0pID0+IHZhbHVlKTtcclxuICAgIH1cclxuICAgIGlmIChpc0NoZWNrQm94SW5wdXQocmVmKSkge1xyXG4gICAgICAgIHJldHVybiBnZXRDaGVja2JveFZhbHVlKF9mLnJlZnMpLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdldEZpZWxkVmFsdWVBcyhpc1VuZGVmaW5lZChyZWYudmFsdWUpID8gX2YucmVmLnZhbHVlIDogcmVmLnZhbHVlLCBfZik7XHJcbn1cblxudmFyIGdldFJlc29sdmVyT3B0aW9ucyA9IChmaWVsZHNOYW1lcywgX2ZpZWxkcywgY3JpdGVyaWFNb2RlLCBzaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uKSA9PiB7XHJcbiAgICBjb25zdCBmaWVsZHMgPSB7fTtcclxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBmaWVsZHNOYW1lcykge1xyXG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xyXG4gICAgICAgIGZpZWxkICYmIHNldChmaWVsZHMsIG5hbWUsIGZpZWxkLl9mKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY3JpdGVyaWFNb2RlLFxyXG4gICAgICAgIG5hbWVzOiBbLi4uZmllbGRzTmFtZXNdLFxyXG4gICAgICAgIGZpZWxkcyxcclxuICAgICAgICBzaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uLFxyXG4gICAgfTtcclxufTtcblxudmFyIGdldFJ1bGVWYWx1ZSA9IChydWxlKSA9PiBpc1VuZGVmaW5lZChydWxlKVxyXG4gICAgPyBydWxlXHJcbiAgICA6IGlzUmVnZXgocnVsZSlcclxuICAgICAgICA/IHJ1bGUuc291cmNlXHJcbiAgICAgICAgOiBpc09iamVjdChydWxlKVxyXG4gICAgICAgICAgICA/IGlzUmVnZXgocnVsZS52YWx1ZSlcclxuICAgICAgICAgICAgICAgID8gcnVsZS52YWx1ZS5zb3VyY2VcclxuICAgICAgICAgICAgICAgIDogcnVsZS52YWx1ZVxyXG4gICAgICAgICAgICA6IHJ1bGU7XG5cbnZhciBoYXNWYWxpZGF0aW9uID0gKG9wdGlvbnMpID0+IG9wdGlvbnMubW91bnQgJiZcclxuICAgIChvcHRpb25zLnJlcXVpcmVkIHx8XHJcbiAgICAgICAgb3B0aW9ucy5taW4gfHxcclxuICAgICAgICBvcHRpb25zLm1heCB8fFxyXG4gICAgICAgIG9wdGlvbnMubWF4TGVuZ3RoIHx8XHJcbiAgICAgICAgb3B0aW9ucy5taW5MZW5ndGggfHxcclxuICAgICAgICBvcHRpb25zLnBhdHRlcm4gfHxcclxuICAgICAgICBvcHRpb25zLnZhbGlkYXRlKTtcblxuZnVuY3Rpb24gc2NoZW1hRXJyb3JMb29rdXAoZXJyb3JzLCBfZmllbGRzLCBuYW1lKSB7XHJcbiAgICBjb25zdCBlcnJvciA9IGdldChlcnJvcnMsIG5hbWUpO1xyXG4gICAgaWYgKGVycm9yIHx8IGlzS2V5KG5hbWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZXJyb3IsXHJcbiAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5hbWVzID0gbmFtZS5zcGxpdCgnLicpO1xyXG4gICAgd2hpbGUgKG5hbWVzLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IG5hbWVzLmpvaW4oJy4nKTtcclxuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBmaWVsZE5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGZvdW5kRXJyb3IgPSBnZXQoZXJyb3JzLCBmaWVsZE5hbWUpO1xyXG4gICAgICAgIGlmIChmaWVsZCAmJiAhQXJyYXkuaXNBcnJheShmaWVsZCkgJiYgbmFtZSAhPT0gZmllbGROYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWUgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZvdW5kRXJyb3IgJiYgZm91bmRFcnJvci50eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBmaWVsZE5hbWUsXHJcbiAgICAgICAgICAgICAgICBlcnJvcjogZm91bmRFcnJvcixcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmFtZXMucG9wKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5hbWUsXHJcbiAgICB9O1xyXG59XG5cbnZhciBza2lwVmFsaWRhdGlvbiA9IChpc0JsdXJFdmVudCwgaXNUb3VjaGVkLCBpc1N1Ym1pdHRlZCwgcmVWYWxpZGF0ZU1vZGUsIG1vZGUpID0+IHtcclxuICAgIGlmIChtb2RlLmlzT25BbGwpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghaXNTdWJtaXR0ZWQgJiYgbW9kZS5pc09uVG91Y2gpIHtcclxuICAgICAgICByZXR1cm4gIShpc1RvdWNoZWQgfHwgaXNCbHVyRXZlbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTdWJtaXR0ZWQgPyByZVZhbGlkYXRlTW9kZS5pc09uQmx1ciA6IG1vZGUuaXNPbkJsdXIpIHtcclxuICAgICAgICByZXR1cm4gIWlzQmx1ckV2ZW50O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTdWJtaXR0ZWQgPyByZVZhbGlkYXRlTW9kZS5pc09uQ2hhbmdlIDogbW9kZS5pc09uQ2hhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzQmx1ckV2ZW50O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XG5cbnZhciB1bnNldEVtcHR5QXJyYXkgPSAocmVmLCBuYW1lKSA9PiAhY29tcGFjdChnZXQocmVmLCBuYW1lKSkubGVuZ3RoICYmIHVuc2V0KHJlZiwgbmFtZSk7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xyXG4gICAgbW9kZTogVkFMSURBVElPTl9NT0RFLm9uU3VibWl0LFxyXG4gICAgcmVWYWxpZGF0ZU1vZGU6IFZBTElEQVRJT05fTU9ERS5vbkNoYW5nZSxcclxuICAgIHNob3VsZEZvY3VzRXJyb3I6IHRydWUsXHJcbn07XHJcbmZ1bmN0aW9uIGNyZWF0ZUZvcm1Db250cm9sKHByb3BzID0ge30sIGZsdXNoUm9vdFJlbmRlcikge1xyXG4gICAgbGV0IF9vcHRpb25zID0ge1xyXG4gICAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxyXG4gICAgICAgIC4uLnByb3BzLFxyXG4gICAgfTtcclxuICAgIGxldCBfZm9ybVN0YXRlID0ge1xyXG4gICAgICAgIHN1Ym1pdENvdW50OiAwLFxyXG4gICAgICAgIGlzRGlydHk6IGZhbHNlLFxyXG4gICAgICAgIGlzTG9hZGluZzogdHJ1ZSxcclxuICAgICAgICBpc1ZhbGlkYXRpbmc6IGZhbHNlLFxyXG4gICAgICAgIGlzU3VibWl0dGVkOiBmYWxzZSxcclxuICAgICAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlLFxyXG4gICAgICAgIGlzU3VibWl0U3VjY2Vzc2Z1bDogZmFsc2UsXHJcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXHJcbiAgICAgICAgdG91Y2hlZEZpZWxkczoge30sXHJcbiAgICAgICAgZGlydHlGaWVsZHM6IHt9LFxyXG4gICAgICAgIGVycm9yczoge30sXHJcbiAgICB9O1xyXG4gICAgbGV0IF9maWVsZHMgPSB7fTtcclxuICAgIGxldCBfZGVmYXVsdFZhbHVlcyA9IGlzT2JqZWN0KF9vcHRpb25zLmRlZmF1bHRWYWx1ZXMpIHx8IGlzT2JqZWN0KF9vcHRpb25zLnZhbHVlcylcclxuICAgICAgICA/IGNsb25lT2JqZWN0KF9vcHRpb25zLmRlZmF1bHRWYWx1ZXMgfHwgX29wdGlvbnMudmFsdWVzKSB8fCB7fVxyXG4gICAgICAgIDoge307XHJcbiAgICBsZXQgX2Zvcm1WYWx1ZXMgPSBfb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyXHJcbiAgICAgICAgPyB7fVxyXG4gICAgICAgIDogY2xvbmVPYmplY3QoX2RlZmF1bHRWYWx1ZXMpO1xyXG4gICAgbGV0IF9zdGF0ZSA9IHtcclxuICAgICAgICBhY3Rpb246IGZhbHNlLFxyXG4gICAgICAgIG1vdW50OiBmYWxzZSxcclxuICAgICAgICB3YXRjaDogZmFsc2UsXHJcbiAgICB9O1xyXG4gICAgbGV0IF9uYW1lcyA9IHtcclxuICAgICAgICBtb3VudDogbmV3IFNldCgpLFxyXG4gICAgICAgIHVuTW91bnQ6IG5ldyBTZXQoKSxcclxuICAgICAgICBhcnJheTogbmV3IFNldCgpLFxyXG4gICAgICAgIHdhdGNoOiBuZXcgU2V0KCksXHJcbiAgICB9O1xyXG4gICAgbGV0IGRlbGF5RXJyb3JDYWxsYmFjaztcclxuICAgIGxldCB0aW1lciA9IDA7XHJcbiAgICBjb25zdCBfcHJveHlGb3JtU3RhdGUgPSB7XHJcbiAgICAgICAgaXNEaXJ0eTogZmFsc2UsXHJcbiAgICAgICAgZGlydHlGaWVsZHM6IGZhbHNlLFxyXG4gICAgICAgIHRvdWNoZWRGaWVsZHM6IGZhbHNlLFxyXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXHJcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXHJcbiAgICAgICAgZXJyb3JzOiBmYWxzZSxcclxuICAgIH07XHJcbiAgICBjb25zdCBfc3ViamVjdHMgPSB7XHJcbiAgICAgICAgdmFsdWVzOiBjcmVhdGVTdWJqZWN0KCksXHJcbiAgICAgICAgYXJyYXk6IGNyZWF0ZVN1YmplY3QoKSxcclxuICAgICAgICBzdGF0ZTogY3JlYXRlU3ViamVjdCgpLFxyXG4gICAgfTtcclxuICAgIGNvbnN0IHNob3VsZENhcHR1cmVEaXJ0eUZpZWxkcyA9IHByb3BzLnJlc2V0T3B0aW9ucyAmJiBwcm9wcy5yZXNldE9wdGlvbnMua2VlcERpcnR5VmFsdWVzO1xyXG4gICAgY29uc3QgdmFsaWRhdGlvbk1vZGVCZWZvcmVTdWJtaXQgPSBnZXRWYWxpZGF0aW9uTW9kZXMoX29wdGlvbnMubW9kZSk7XHJcbiAgICBjb25zdCB2YWxpZGF0aW9uTW9kZUFmdGVyU3VibWl0ID0gZ2V0VmFsaWRhdGlvbk1vZGVzKF9vcHRpb25zLnJlVmFsaWRhdGVNb2RlKTtcclxuICAgIGNvbnN0IHNob3VsZERpc3BsYXlBbGxBc3NvY2lhdGVkRXJyb3JzID0gX29wdGlvbnMuY3JpdGVyaWFNb2RlID09PSBWQUxJREFUSU9OX01PREUuYWxsO1xyXG4gICAgY29uc3QgZGVib3VuY2UgPSAoY2FsbGJhY2spID0+ICh3YWl0KSA9PiB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIHdhaXQpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IF91cGRhdGVWYWxpZCA9IGFzeW5jIChzaG91bGRVcGRhdGVWYWxpZCkgPT4ge1xyXG4gICAgICAgIGlmIChfcHJveHlGb3JtU3RhdGUuaXNWYWxpZCB8fCBzaG91bGRVcGRhdGVWYWxpZCkge1xyXG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gX29wdGlvbnMucmVzb2x2ZXJcclxuICAgICAgICAgICAgICAgID8gaXNFbXB0eU9iamVjdCgoYXdhaXQgX2V4ZWN1dGVTY2hlbWEoKSkuZXJyb3JzKVxyXG4gICAgICAgICAgICAgICAgOiBhd2FpdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24oX2ZpZWxkcywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkICE9PSBfZm9ybVN0YXRlLmlzVmFsaWQpIHtcclxuICAgICAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcclxuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgX3VwZGF0ZUlzVmFsaWRhdGluZyA9ICh2YWx1ZSkgPT4gX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWRhdGluZyAmJlxyXG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcclxuICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiB2YWx1ZSxcclxuICAgICAgICB9KTtcclxuICAgIGNvbnN0IF91cGRhdGVGaWVsZEFycmF5ID0gKG5hbWUsIHZhbHVlcyA9IFtdLCBtZXRob2QsIGFyZ3MsIHNob3VsZFNldFZhbHVlcyA9IHRydWUsIHNob3VsZFVwZGF0ZUZpZWxkc0FuZFN0YXRlID0gdHJ1ZSkgPT4ge1xyXG4gICAgICAgIGlmIChhcmdzICYmIG1ldGhvZCkge1xyXG4gICAgICAgICAgICBfc3RhdGUuYWN0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZUZpZWxkc0FuZFN0YXRlICYmIEFycmF5LmlzQXJyYXkoZ2V0KF9maWVsZHMsIG5hbWUpKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRWYWx1ZXMgPSBtZXRob2QoZ2V0KF9maWVsZHMsIG5hbWUpLCBhcmdzLmFyZ0EsIGFyZ3MuYXJnQik7XHJcbiAgICAgICAgICAgICAgICBzaG91bGRTZXRWYWx1ZXMgJiYgc2V0KF9maWVsZHMsIG5hbWUsIGZpZWxkVmFsdWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlRmllbGRzQW5kU3RhdGUgJiZcclxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZ2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IG1ldGhvZChnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpLCBhcmdzLmFyZ0EsIGFyZ3MuYXJnQik7XHJcbiAgICAgICAgICAgICAgICBzaG91bGRTZXRWYWx1ZXMgJiYgc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lLCBlcnJvcnMpO1xyXG4gICAgICAgICAgICAgICAgdW5zZXRFbXB0eUFycmF5KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoX3Byb3h5Rm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMgJiZcclxuICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkc0FuZFN0YXRlICYmXHJcbiAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KGdldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUpKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG91Y2hlZEZpZWxkcyA9IG1ldGhvZChnZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKSwgYXJncy5hcmdBLCBhcmdzLmFyZ0IpO1xyXG4gICAgICAgICAgICAgICAgc2hvdWxkU2V0VmFsdWVzICYmIHNldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUsIHRvdWNoZWRGaWVsZHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChfcHJveHlGb3JtU3RhdGUuZGlydHlGaWVsZHMpIHtcclxuICAgICAgICAgICAgICAgIF9mb3JtU3RhdGUuZGlydHlGaWVsZHMgPSBnZXREaXJ0eUZpZWxkcyhfZGVmYXVsdFZhbHVlcywgX2Zvcm1WYWx1ZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcclxuICAgICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgICBpc0RpcnR5OiBfZ2V0RGlydHkobmFtZSwgdmFsdWVzKSxcclxuICAgICAgICAgICAgICAgIGRpcnR5RmllbGRzOiBfZm9ybVN0YXRlLmRpcnR5RmllbGRzLFxyXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcclxuICAgICAgICAgICAgICAgIGlzVmFsaWQ6IF9mb3JtU3RhdGUuaXNWYWxpZCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIHZhbHVlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHVwZGF0ZUVycm9ycyA9IChuYW1lLCBlcnJvcikgPT4ge1xyXG4gICAgICAgIHNldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSwgZXJyb3IpO1xyXG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcclxuICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBjb25zdCB1cGRhdGVWYWxpZEFuZFZhbHVlID0gKG5hbWUsIHNob3VsZFNraXBTZXRWYWx1ZUFzLCB2YWx1ZSwgcmVmKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XHJcbiAgICAgICAgaWYgKGZpZWxkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IGdldChfZm9ybVZhbHVlcywgbmFtZSwgaXNVbmRlZmluZWQodmFsdWUpID8gZ2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lKSA6IHZhbHVlKTtcclxuICAgICAgICAgICAgaXNVbmRlZmluZWQoZGVmYXVsdFZhbHVlKSB8fFxyXG4gICAgICAgICAgICAgICAgKHJlZiAmJiByZWYuZGVmYXVsdENoZWNrZWQpIHx8XHJcbiAgICAgICAgICAgICAgICBzaG91bGRTa2lwU2V0VmFsdWVBc1xyXG4gICAgICAgICAgICAgICAgPyBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIHNob3VsZFNraXBTZXRWYWx1ZUFzID8gZGVmYXVsdFZhbHVlIDogZ2V0RmllbGRWYWx1ZShmaWVsZC5fZikpXHJcbiAgICAgICAgICAgICAgICA6IHNldEZpZWxkVmFsdWUobmFtZSwgZGVmYXVsdFZhbHVlKTtcclxuICAgICAgICAgICAgX3N0YXRlLm1vdW50ICYmIF91cGRhdGVWYWxpZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCB1cGRhdGVUb3VjaEFuZERpcnR5ID0gKG5hbWUsIGZpZWxkVmFsdWUsIGlzQmx1ckV2ZW50LCBzaG91bGREaXJ0eSwgc2hvdWxkUmVuZGVyKSA9PiB7XHJcbiAgICAgICAgbGV0IHNob3VsZFVwZGF0ZUZpZWxkID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGlzUHJldmlvdXNEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHtcclxuICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICghaXNCbHVyRXZlbnQgfHwgc2hvdWxkRGlydHkpIHtcclxuICAgICAgICAgICAgaWYgKF9wcm94eUZvcm1TdGF0ZS5pc0RpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICBpc1ByZXZpb3VzRGlydHkgPSBfZm9ybVN0YXRlLmlzRGlydHk7XHJcbiAgICAgICAgICAgICAgICBfZm9ybVN0YXRlLmlzRGlydHkgPSBvdXRwdXQuaXNEaXJ0eSA9IF9nZXREaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlRmllbGQgPSBpc1ByZXZpb3VzRGlydHkgIT09IG91dHB1dC5pc0RpcnR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudEZpZWxkUHJpc3RpbmUgPSBkZWVwRXF1YWwoZ2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lKSwgZmllbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgIGlzUHJldmlvdXNEaXJ0eSA9IGdldChfZm9ybVN0YXRlLmRpcnR5RmllbGRzLCBuYW1lKTtcclxuICAgICAgICAgICAgaXNDdXJyZW50RmllbGRQcmlzdGluZVxyXG4gICAgICAgICAgICAgICAgPyB1bnNldChfZm9ybVN0YXRlLmRpcnR5RmllbGRzLCBuYW1lKVxyXG4gICAgICAgICAgICAgICAgOiBzZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIG91dHB1dC5kaXJ0eUZpZWxkcyA9IF9mb3JtU3RhdGUuZGlydHlGaWVsZHM7XHJcbiAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkID1cclxuICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKF9wcm94eUZvcm1TdGF0ZS5kaXJ0eUZpZWxkcyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZpb3VzRGlydHkgIT09ICFpc0N1cnJlbnRGaWVsZFByaXN0aW5lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQmx1ckV2ZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzUHJldmlvdXNGaWVsZFRvdWNoZWQgPSBnZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKTtcclxuICAgICAgICAgICAgaWYgKCFpc1ByZXZpb3VzRmllbGRUb3VjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICBzZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lLCBpc0JsdXJFdmVudCk7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQudG91Y2hlZEZpZWxkcyA9IF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkcztcclxuICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkID1cclxuICAgICAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVGaWVsZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoX3Byb3h5Rm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJldmlvdXNGaWVsZFRvdWNoZWQgIT09IGlzQmx1ckV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzaG91bGRVcGRhdGVGaWVsZCAmJiBzaG91bGRSZW5kZXIgJiYgX3N1YmplY3RzLnN0YXRlLm5leHQob3V0cHV0KTtcclxuICAgICAgICByZXR1cm4gc2hvdWxkVXBkYXRlRmllbGQgPyBvdXRwdXQgOiB7fTtcclxuICAgIH07XHJcbiAgICBjb25zdCBzaG91bGRSZW5kZXJCeUVycm9yID0gKG5hbWUsIGlzVmFsaWQsIGVycm9yLCBmaWVsZFN0YXRlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcHJldmlvdXNGaWVsZEVycm9yID0gZ2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcclxuICAgICAgICBjb25zdCBzaG91bGRVcGRhdGVWYWxpZCA9IF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkICYmXHJcbiAgICAgICAgICAgIGlzQm9vbGVhbihpc1ZhbGlkKSAmJlxyXG4gICAgICAgICAgICBfZm9ybVN0YXRlLmlzVmFsaWQgIT09IGlzVmFsaWQ7XHJcbiAgICAgICAgaWYgKHByb3BzLmRlbGF5RXJyb3IgJiYgZXJyb3IpIHtcclxuICAgICAgICAgICAgZGVsYXlFcnJvckNhbGxiYWNrID0gZGVib3VuY2UoKCkgPT4gdXBkYXRlRXJyb3JzKG5hbWUsIGVycm9yKSk7XHJcbiAgICAgICAgICAgIGRlbGF5RXJyb3JDYWxsYmFjayhwcm9wcy5kZWxheUVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XHJcbiAgICAgICAgICAgIGRlbGF5RXJyb3JDYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgICAgIGVycm9yXHJcbiAgICAgICAgICAgICAgICA/IHNldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSwgZXJyb3IpXHJcbiAgICAgICAgICAgICAgICA6IHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChlcnJvciA/ICFkZWVwRXF1YWwocHJldmlvdXNGaWVsZEVycm9yLCBlcnJvcikgOiBwcmV2aW91c0ZpZWxkRXJyb3IpIHx8XHJcbiAgICAgICAgICAgICFpc0VtcHR5T2JqZWN0KGZpZWxkU3RhdGUpIHx8XHJcbiAgICAgICAgICAgIHNob3VsZFVwZGF0ZVZhbGlkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGb3JtU3RhdGUgPSB7XHJcbiAgICAgICAgICAgICAgICAuLi5maWVsZFN0YXRlLFxyXG4gICAgICAgICAgICAgICAgLi4uKHNob3VsZFVwZGF0ZVZhbGlkICYmIGlzQm9vbGVhbihpc1ZhbGlkKSA/IHsgaXNWYWxpZCB9IDoge30pLFxyXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcclxuICAgICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIF9mb3JtU3RhdGUgPSB7XHJcbiAgICAgICAgICAgICAgICAuLi5fZm9ybVN0YXRlLFxyXG4gICAgICAgICAgICAgICAgLi4udXBkYXRlZEZvcm1TdGF0ZSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQodXBkYXRlZEZvcm1TdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF91cGRhdGVJc1ZhbGlkYXRpbmcoZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IF9leGVjdXRlU2NoZW1hID0gYXN5bmMgKG5hbWUpID0+IF9vcHRpb25zLnJlc29sdmVyKF9mb3JtVmFsdWVzLCBfb3B0aW9ucy5jb250ZXh0LCBnZXRSZXNvbHZlck9wdGlvbnMobmFtZSB8fCBfbmFtZXMubW91bnQsIF9maWVsZHMsIF9vcHRpb25zLmNyaXRlcmlhTW9kZSwgX29wdGlvbnMuc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbikpO1xyXG4gICAgY29uc3QgZXhlY3V0ZVNjaGVtYUFuZFVwZGF0ZVN0YXRlID0gYXN5bmMgKG5hbWVzKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBlcnJvcnMgfSA9IGF3YWl0IF9leGVjdXRlU2NoZW1hKCk7XHJcbiAgICAgICAgaWYgKG5hbWVzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBnZXQoZXJyb3JzLCBuYW1lKTtcclxuICAgICAgICAgICAgICAgIGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgPyBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9yKVxyXG4gICAgICAgICAgICAgICAgICAgIDogdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBfZm9ybVN0YXRlLmVycm9ycyA9IGVycm9ycztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVycm9ycztcclxuICAgIH07XHJcbiAgICBjb25zdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24gPSBhc3luYyAoZmllbGRzLCBzaG91bGRPbmx5Q2hlY2tWYWxpZCwgY29udGV4dCA9IHtcclxuICAgICAgICB2YWxpZDogdHJ1ZSxcclxuICAgIH0pID0+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZmllbGRzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZmllbGRzW25hbWVdO1xyXG4gICAgICAgICAgICBpZiAoZmllbGQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgX2YsIC4uLmZpZWxkVmFsdWUgfSA9IGZpZWxkO1xyXG4gICAgICAgICAgICAgICAgaWYgKF9mKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNGaWVsZEFycmF5Um9vdCA9IF9uYW1lcy5hcnJheS5oYXMoX2YubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGRFcnJvciA9IGF3YWl0IHZhbGlkYXRlRmllbGQoZmllbGQsIF9mb3JtVmFsdWVzLCBzaG91bGREaXNwbGF5QWxsQXNzb2NpYXRlZEVycm9ycywgX29wdGlvbnMuc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiwgaXNGaWVsZEFycmF5Um9vdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkRXJyb3JbX2YubmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC52YWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkT25seUNoZWNrVmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICFzaG91bGRPbmx5Q2hlY2tWYWxpZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoZ2V0KGZpZWxkRXJyb3IsIF9mLm5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGlzRmllbGRBcnJheVJvb3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHVwZGF0ZUZpZWxkQXJyYXlSb290RXJyb3IoX2Zvcm1TdGF0ZS5lcnJvcnMsIGZpZWxkRXJyb3IsIF9mLm5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIF9mLm5hbWUsIGZpZWxkRXJyb3JbX2YubmFtZV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBfZi5uYW1lKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaWVsZFZhbHVlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGF3YWl0IGV4ZWN1dGVCdWlsdEluVmFsaWRhdGlvbihmaWVsZFZhbHVlLCBzaG91bGRPbmx5Q2hlY2tWYWxpZCwgY29udGV4dCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb250ZXh0LnZhbGlkO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IF9yZW1vdmVVbm1vdW50ZWQgPSAoKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIF9uYW1lcy51bk1vdW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xyXG4gICAgICAgICAgICBmaWVsZCAmJlxyXG4gICAgICAgICAgICAgICAgKGZpZWxkLl9mLnJlZnNcclxuICAgICAgICAgICAgICAgICAgICA/IGZpZWxkLl9mLnJlZnMuZXZlcnkoKHJlZikgPT4gIWxpdmUocmVmKSlcclxuICAgICAgICAgICAgICAgICAgICA6ICFsaXZlKGZpZWxkLl9mLnJlZikpICYmXHJcbiAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyKG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfbmFtZXMudW5Nb3VudCA9IG5ldyBTZXQoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBfZ2V0RGlydHkgPSAobmFtZSwgZGF0YSkgPT4gKG5hbWUgJiYgZGF0YSAmJiBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIGRhdGEpLFxyXG4gICAgICAgICFkZWVwRXF1YWwoZ2V0VmFsdWVzKCksIF9kZWZhdWx0VmFsdWVzKSk7XHJcbiAgICBjb25zdCBfZ2V0V2F0Y2ggPSAobmFtZXMsIGRlZmF1bHRWYWx1ZSwgaXNHbG9iYWwpID0+IGdlbmVyYXRlV2F0Y2hPdXRwdXQobmFtZXMsIF9uYW1lcywge1xyXG4gICAgICAgIC4uLihfc3RhdGUubW91bnRcclxuICAgICAgICAgICAgPyBfZm9ybVZhbHVlc1xyXG4gICAgICAgICAgICA6IGlzVW5kZWZpbmVkKGRlZmF1bHRWYWx1ZSlcclxuICAgICAgICAgICAgICAgID8gX2RlZmF1bHRWYWx1ZXNcclxuICAgICAgICAgICAgICAgIDogaXNTdHJpbmcobmFtZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgPyB7IFtuYW1lc106IGRlZmF1bHRWYWx1ZSB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWUpLFxyXG4gICAgfSwgaXNHbG9iYWwsIGRlZmF1bHRWYWx1ZSk7XHJcbiAgICBjb25zdCBfZ2V0RmllbGRBcnJheSA9IChuYW1lKSA9PiBjb21wYWN0KGdldChfc3RhdGUubW91bnQgPyBfZm9ybVZhbHVlcyA6IF9kZWZhdWx0VmFsdWVzLCBuYW1lLCBwcm9wcy5zaG91bGRVbnJlZ2lzdGVyID8gZ2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lLCBbXSkgOiBbXSkpO1xyXG4gICAgY29uc3Qgc2V0RmllbGRWYWx1ZSA9IChuYW1lLCB2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XHJcbiAgICAgICAgbGV0IGZpZWxkVmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICBpZiAoZmllbGQpIHtcclxuICAgICAgICAgICAgY29uc3QgZmllbGRSZWZlcmVuY2UgPSBmaWVsZC5fZjtcclxuICAgICAgICAgICAgaWYgKGZpZWxkUmVmZXJlbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAhZmllbGRSZWZlcmVuY2UuZGlzYWJsZWQgJiZcclxuICAgICAgICAgICAgICAgICAgICBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIGdldEZpZWxkVmFsdWVBcyh2YWx1ZSwgZmllbGRSZWZlcmVuY2UpKTtcclxuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgPVxyXG4gICAgICAgICAgICAgICAgICAgIGlzSFRNTEVsZW1lbnQoZmllbGRSZWZlcmVuY2UucmVmKSAmJiBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTXVsdGlwbGVTZWxlY3QoZmllbGRSZWZlcmVuY2UucmVmKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIFsuLi5maWVsZFJlZmVyZW5jZS5yZWYub3B0aW9uc10uZm9yRWFjaCgob3B0aW9uUmVmKSA9PiAob3B0aW9uUmVmLnNlbGVjdGVkID0gZmllbGRWYWx1ZS5pbmNsdWRlcyhvcHRpb25SZWYudmFsdWUpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZFJlZmVyZW5jZS5yZWZzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2hlY2tCb3hJbnB1dChmaWVsZFJlZmVyZW5jZS5yZWYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkUmVmZXJlbmNlLnJlZnMubGVuZ3RoID4gMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBmaWVsZFJlZmVyZW5jZS5yZWZzLmZvckVhY2goKGNoZWNrYm94UmVmKSA9PiAoIWNoZWNrYm94UmVmLmRlZmF1bHRDaGVja2VkIHx8ICFjaGVja2JveFJlZi5kaXNhYmxlZCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2hlY2tib3hSZWYuY2hlY2tlZCA9IEFycmF5LmlzQXJyYXkoZmllbGRWYWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAhIWZpZWxkVmFsdWUuZmluZCgoZGF0YSkgPT4gZGF0YSA9PT0gY2hlY2tib3hSZWYudmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZmllbGRWYWx1ZSA9PT0gY2hlY2tib3hSZWYudmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBmaWVsZFJlZmVyZW5jZS5yZWZzWzBdICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZpZWxkUmVmZXJlbmNlLnJlZnNbMF0uY2hlY2tlZCA9ICEhZmllbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFJlZmVyZW5jZS5yZWZzLmZvckVhY2goKHJhZGlvUmVmKSA9PiAocmFkaW9SZWYuY2hlY2tlZCA9IHJhZGlvUmVmLnZhbHVlID09PSBmaWVsZFZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNGaWxlSW5wdXQoZmllbGRSZWZlcmVuY2UucmVmKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkUmVmZXJlbmNlLnJlZi52YWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGRSZWZlcmVuY2UucmVmLnZhbHVlID0gZmllbGRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkUmVmZXJlbmNlLnJlZi50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdWJqZWN0cy52YWx1ZXMubmV4dCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiB7IC4uLl9mb3JtVmFsdWVzIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAob3B0aW9ucy5zaG91bGREaXJ0eSB8fCBvcHRpb25zLnNob3VsZFRvdWNoKSAmJlxyXG4gICAgICAgICAgICB1cGRhdGVUb3VjaEFuZERpcnR5KG5hbWUsIGZpZWxkVmFsdWUsIG9wdGlvbnMuc2hvdWxkVG91Y2gsIG9wdGlvbnMuc2hvdWxkRGlydHksIHRydWUpO1xyXG4gICAgICAgIG9wdGlvbnMuc2hvdWxkVmFsaWRhdGUgJiYgdHJpZ2dlcihuYW1lKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBzZXRWYWx1ZXMgPSAobmFtZSwgdmFsdWUsIG9wdGlvbnMpID0+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkS2V5IGluIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkVmFsdWUgPSB2YWx1ZVtmaWVsZEtleV07XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IGAke25hbWV9LiR7ZmllbGRLZXl9YDtcclxuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgZmllbGROYW1lKTtcclxuICAgICAgICAgICAgKF9uYW1lcy5hcnJheS5oYXMobmFtZSkgfHxcclxuICAgICAgICAgICAgICAgICFpc1ByaW1pdGl2ZShmaWVsZFZhbHVlKSB8fFxyXG4gICAgICAgICAgICAgICAgKGZpZWxkICYmICFmaWVsZC5fZikpICYmXHJcbiAgICAgICAgICAgICAgICAhaXNEYXRlT2JqZWN0KGZpZWxkVmFsdWUpXHJcbiAgICAgICAgICAgICAgICA/IHNldFZhbHVlcyhmaWVsZE5hbWUsIGZpZWxkVmFsdWUsIG9wdGlvbnMpXHJcbiAgICAgICAgICAgICAgICA6IHNldEZpZWxkVmFsdWUoZmllbGROYW1lLCBmaWVsZFZhbHVlLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2V0VmFsdWUgPSAobmFtZSwgdmFsdWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGlzRmllbGRBcnJheSA9IF9uYW1lcy5hcnJheS5oYXMobmFtZSk7XHJcbiAgICAgICAgY29uc3QgY2xvbmVWYWx1ZSA9IGNsb25lT2JqZWN0KHZhbHVlKTtcclxuICAgICAgICBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIGNsb25lVmFsdWUpO1xyXG4gICAgICAgIGlmIChpc0ZpZWxkQXJyYXkpIHtcclxuICAgICAgICAgICAgX3N1YmplY3RzLmFycmF5Lm5leHQoe1xyXG4gICAgICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgICAgIHZhbHVlczogeyAuLi5fZm9ybVZhbHVlcyB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKChfcHJveHlGb3JtU3RhdGUuaXNEaXJ0eSB8fCBfcHJveHlGb3JtU3RhdGUuZGlydHlGaWVsZHMpICYmXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNob3VsZERpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBkaXJ0eUZpZWxkczogZ2V0RGlydHlGaWVsZHMoX2RlZmF1bHRWYWx1ZXMsIF9mb3JtVmFsdWVzKSxcclxuICAgICAgICAgICAgICAgICAgICBpc0RpcnR5OiBfZ2V0RGlydHkobmFtZSwgY2xvbmVWYWx1ZSksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZmllbGQgJiYgIWZpZWxkLl9mICYmICFpc051bGxPclVuZGVmaW5lZChjbG9uZVZhbHVlKVxyXG4gICAgICAgICAgICAgICAgPyBzZXRWYWx1ZXMobmFtZSwgY2xvbmVWYWx1ZSwgb3B0aW9ucylcclxuICAgICAgICAgICAgICAgIDogc2V0RmllbGRWYWx1ZShuYW1lLCBjbG9uZVZhbHVlLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaXNXYXRjaGVkKG5hbWUsIF9uYW1lcykgJiYgX3N1YmplY3RzLnN0YXRlLm5leHQoeyAuLi5fZm9ybVN0YXRlIH0pO1xyXG4gICAgICAgIF9zdWJqZWN0cy52YWx1ZXMubmV4dCh7XHJcbiAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgIHZhbHVlczogeyAuLi5fZm9ybVZhbHVlcyB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICFfc3RhdGUubW91bnQgJiYgZmx1c2hSb290UmVuZGVyKCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgb25DaGFuZ2UgPSBhc3luYyAoZXZlbnQpID0+IHtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XHJcbiAgICAgICAgbGV0IG5hbWUgPSB0YXJnZXQubmFtZTtcclxuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcclxuICAgICAgICBjb25zdCBnZXRDdXJyZW50RmllbGRWYWx1ZSA9ICgpID0+IHRhcmdldC50eXBlID8gZ2V0RmllbGRWYWx1ZShmaWVsZC5fZikgOiBnZXRFdmVudFZhbHVlKGV2ZW50KTtcclxuICAgICAgICBpZiAoZmllbGQpIHtcclxuICAgICAgICAgICAgbGV0IGVycm9yO1xyXG4gICAgICAgICAgICBsZXQgaXNWYWxpZDtcclxuICAgICAgICAgICAgY29uc3QgZmllbGRWYWx1ZSA9IGdldEN1cnJlbnRGaWVsZFZhbHVlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzQmx1ckV2ZW50ID0gZXZlbnQudHlwZSA9PT0gRVZFTlRTLkJMVVIgfHwgZXZlbnQudHlwZSA9PT0gRVZFTlRTLkZPQ1VTX09VVDtcclxuICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2tpcFZhbGlkYXRpb24gPSAoIWhhc1ZhbGlkYXRpb24oZmllbGQuX2YpICYmXHJcbiAgICAgICAgICAgICAgICAhX29wdGlvbnMucmVzb2x2ZXIgJiZcclxuICAgICAgICAgICAgICAgICFnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpICYmXHJcbiAgICAgICAgICAgICAgICAhZmllbGQuX2YuZGVwcykgfHxcclxuICAgICAgICAgICAgICAgIHNraXBWYWxpZGF0aW9uKGlzQmx1ckV2ZW50LCBnZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKSwgX2Zvcm1TdGF0ZS5pc1N1Ym1pdHRlZCwgdmFsaWRhdGlvbk1vZGVBZnRlclN1Ym1pdCwgdmFsaWRhdGlvbk1vZGVCZWZvcmVTdWJtaXQpO1xyXG4gICAgICAgICAgICBjb25zdCB3YXRjaGVkID0gaXNXYXRjaGVkKG5hbWUsIF9uYW1lcywgaXNCbHVyRXZlbnQpO1xyXG4gICAgICAgICAgICBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIGZpZWxkVmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAoaXNCbHVyRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIGZpZWxkLl9mLm9uQmx1ciAmJiBmaWVsZC5fZi5vbkJsdXIoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgZGVsYXlFcnJvckNhbGxiYWNrICYmIGRlbGF5RXJyb3JDYWxsYmFjaygwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5fZi5vbkNoYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgZmllbGQuX2Yub25DaGFuZ2UoZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU3RhdGUgPSB1cGRhdGVUb3VjaEFuZERpcnR5KG5hbWUsIGZpZWxkVmFsdWUsIGlzQmx1ckV2ZW50LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFJlbmRlciA9ICFpc0VtcHR5T2JqZWN0KGZpZWxkU3RhdGUpIHx8IHdhdGNoZWQ7XHJcbiAgICAgICAgICAgICFpc0JsdXJFdmVudCAmJlxyXG4gICAgICAgICAgICAgICAgX3N1YmplY3RzLnZhbHVlcy5uZXh0KHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGV2ZW50LnR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiB7IC4uLl9mb3JtVmFsdWVzIH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHNob3VsZFNraXBWYWxpZGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBfcHJveHlGb3JtU3RhdGUuaXNWYWxpZCAmJiBfdXBkYXRlVmFsaWQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoc2hvdWxkUmVuZGVyICYmXHJcbiAgICAgICAgICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoeyBuYW1lLCAuLi4od2F0Y2hlZCA/IHt9IDogZmllbGRTdGF0ZSkgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICFpc0JsdXJFdmVudCAmJiB3YXRjaGVkICYmIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHsgLi4uX2Zvcm1TdGF0ZSB9KTtcclxuICAgICAgICAgICAgX3VwZGF0ZUlzVmFsaWRhdGluZyh0cnVlKTtcclxuICAgICAgICAgICAgaWYgKF9vcHRpb25zLnJlc29sdmVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9ycyB9ID0gYXdhaXQgX2V4ZWN1dGVTY2hlbWEoW25hbWVdKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzRXJyb3JMb29rdXBSZXN1bHQgPSBzY2hlbWFFcnJvckxvb2t1cChfZm9ybVN0YXRlLmVycm9ycywgX2ZpZWxkcywgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvckxvb2t1cFJlc3VsdCA9IHNjaGVtYUVycm9yTG9va3VwKGVycm9ycywgX2ZpZWxkcywgcHJldmlvdXNFcnJvckxvb2t1cFJlc3VsdC5uYW1lIHx8IG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlcnJvckxvb2t1cFJlc3VsdC5lcnJvcjtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBlcnJvckxvb2t1cFJlc3VsdC5uYW1lO1xyXG4gICAgICAgICAgICAgICAgaXNWYWxpZCA9IGlzRW1wdHlPYmplY3QoZXJyb3JzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVycm9yID0gKGF3YWl0IHZhbGlkYXRlRmllbGQoZmllbGQsIF9mb3JtVmFsdWVzLCBzaG91bGREaXNwbGF5QWxsQXNzb2NpYXRlZEVycm9ycywgX29wdGlvbnMuc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbikpW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gYXdhaXQgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uKF9maWVsZHMsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpZWxkLl9mLmRlcHMgJiZcclxuICAgICAgICAgICAgICAgIHRyaWdnZXIoZmllbGQuX2YuZGVwcyk7XHJcbiAgICAgICAgICAgIHNob3VsZFJlbmRlckJ5RXJyb3IobmFtZSwgaXNWYWxpZCwgZXJyb3IsIGZpZWxkU3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCB0cmlnZ2VyID0gYXN5bmMgKG5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xyXG4gICAgICAgIGxldCBpc1ZhbGlkO1xyXG4gICAgICAgIGxldCB2YWxpZGF0aW9uUmVzdWx0O1xyXG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSBjb252ZXJ0VG9BcnJheVBheWxvYWQobmFtZSk7XHJcbiAgICAgICAgX3VwZGF0ZUlzVmFsaWRhdGluZyh0cnVlKTtcclxuICAgICAgICBpZiAoX29wdGlvbnMucmVzb2x2ZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gYXdhaXQgZXhlY3V0ZVNjaGVtYUFuZFVwZGF0ZVN0YXRlKGlzVW5kZWZpbmVkKG5hbWUpID8gbmFtZSA6IGZpZWxkTmFtZXMpO1xyXG4gICAgICAgICAgICBpc1ZhbGlkID0gaXNFbXB0eU9iamVjdChlcnJvcnMpO1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0ID0gbmFtZVxyXG4gICAgICAgICAgICAgICAgPyAhZmllbGROYW1lcy5zb21lKChuYW1lKSA9PiBnZXQoZXJyb3JzLCBuYW1lKSlcclxuICAgICAgICAgICAgICAgIDogaXNWYWxpZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobmFtZSkge1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0ID0gKGF3YWl0IFByb21pc2UuYWxsKGZpZWxkTmFtZXMubWFwKGFzeW5jIChmaWVsZE5hbWUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIGZpZWxkTmFtZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uKGZpZWxkICYmIGZpZWxkLl9mID8geyBbZmllbGROYW1lXTogZmllbGQgfSA6IGZpZWxkKTtcclxuICAgICAgICAgICAgfSkpKS5ldmVyeShCb29sZWFuKTtcclxuICAgICAgICAgICAgISghdmFsaWRhdGlvblJlc3VsdCAmJiAhX2Zvcm1TdGF0ZS5pc1ZhbGlkKSAmJiBfdXBkYXRlVmFsaWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQgPSBpc1ZhbGlkID0gYXdhaXQgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uKF9maWVsZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XHJcbiAgICAgICAgICAgIC4uLighaXNTdHJpbmcobmFtZSkgfHxcclxuICAgICAgICAgICAgICAgIChfcHJveHlGb3JtU3RhdGUuaXNWYWxpZCAmJiBpc1ZhbGlkICE9PSBfZm9ybVN0YXRlLmlzVmFsaWQpXHJcbiAgICAgICAgICAgICAgICA/IHt9XHJcbiAgICAgICAgICAgICAgICA6IHsgbmFtZSB9KSxcclxuICAgICAgICAgICAgLi4uKF9vcHRpb25zLnJlc29sdmVyIHx8ICFuYW1lID8geyBpc1ZhbGlkIH0gOiB7fSksXHJcbiAgICAgICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXHJcbiAgICAgICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgb3B0aW9ucy5zaG91bGRGb2N1cyAmJlxyXG4gICAgICAgICAgICAhdmFsaWRhdGlvblJlc3VsdCAmJlxyXG4gICAgICAgICAgICBmb2N1c0ZpZWxkQnkoX2ZpZWxkcywgKGtleSkgPT4ga2V5ICYmIGdldChfZm9ybVN0YXRlLmVycm9ycywga2V5KSwgbmFtZSA/IGZpZWxkTmFtZXMgOiBfbmFtZXMubW91bnQpO1xyXG4gICAgICAgIHJldHVybiB2YWxpZGF0aW9uUmVzdWx0O1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGdldFZhbHVlcyA9IChmaWVsZE5hbWVzKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdmFsdWVzID0ge1xyXG4gICAgICAgICAgICAuLi5fZGVmYXVsdFZhbHVlcyxcclxuICAgICAgICAgICAgLi4uKF9zdGF0ZS5tb3VudCA/IF9mb3JtVmFsdWVzIDoge30pLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGlzVW5kZWZpbmVkKGZpZWxkTmFtZXMpXHJcbiAgICAgICAgICAgID8gdmFsdWVzXHJcbiAgICAgICAgICAgIDogaXNTdHJpbmcoZmllbGROYW1lcylcclxuICAgICAgICAgICAgICAgID8gZ2V0KHZhbHVlcywgZmllbGROYW1lcylcclxuICAgICAgICAgICAgICAgIDogZmllbGROYW1lcy5tYXAoKG5hbWUpID0+IGdldCh2YWx1ZXMsIG5hbWUpKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBnZXRGaWVsZFN0YXRlID0gKG5hbWUsIGZvcm1TdGF0ZSkgPT4gKHtcclxuICAgICAgICBpbnZhbGlkOiAhIWdldCgoZm9ybVN0YXRlIHx8IF9mb3JtU3RhdGUpLmVycm9ycywgbmFtZSksXHJcbiAgICAgICAgaXNEaXJ0eTogISFnZXQoKGZvcm1TdGF0ZSB8fCBfZm9ybVN0YXRlKS5kaXJ0eUZpZWxkcywgbmFtZSksXHJcbiAgICAgICAgaXNUb3VjaGVkOiAhIWdldCgoZm9ybVN0YXRlIHx8IF9mb3JtU3RhdGUpLnRvdWNoZWRGaWVsZHMsIG5hbWUpLFxyXG4gICAgICAgIGVycm9yOiBnZXQoKGZvcm1TdGF0ZSB8fCBfZm9ybVN0YXRlKS5lcnJvcnMsIG5hbWUpLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBjbGVhckVycm9ycyA9IChuYW1lKSA9PiB7XHJcbiAgICAgICAgbmFtZSAmJlxyXG4gICAgICAgICAgICBjb252ZXJ0VG9BcnJheVBheWxvYWQobmFtZSkuZm9yRWFjaCgoaW5wdXROYW1lKSA9PiB1bnNldChfZm9ybVN0YXRlLmVycm9ycywgaW5wdXROYW1lKSk7XHJcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xyXG4gICAgICAgICAgICBlcnJvcnM6IG5hbWUgPyBfZm9ybVN0YXRlLmVycm9ycyA6IHt9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHNldEVycm9yID0gKG5hbWUsIGVycm9yLCBvcHRpb25zKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVmID0gKGdldChfZmllbGRzLCBuYW1lLCB7IF9mOiB7fSB9KS5fZiB8fCB7fSkucmVmO1xyXG4gICAgICAgIHNldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSwge1xyXG4gICAgICAgICAgICAuLi5lcnJvcixcclxuICAgICAgICAgICAgcmVmLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcclxuICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcclxuICAgICAgICAgICAgaXNWYWxpZDogZmFsc2UsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLnNob3VsZEZvY3VzICYmIHJlZiAmJiByZWYuZm9jdXMgJiYgcmVmLmZvY3VzKCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgd2F0Y2ggPSAobmFtZSwgZGVmYXVsdFZhbHVlKSA9PiBpc0Z1bmN0aW9uKG5hbWUpXHJcbiAgICAgICAgPyBfc3ViamVjdHMudmFsdWVzLnN1YnNjcmliZSh7XHJcbiAgICAgICAgICAgIG5leHQ6IChwYXlsb2FkKSA9PiBuYW1lKF9nZXRXYXRjaCh1bmRlZmluZWQsIGRlZmF1bHRWYWx1ZSksIHBheWxvYWQpLFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgOiBfZ2V0V2F0Y2gobmFtZSwgZGVmYXVsdFZhbHVlLCB0cnVlKTtcclxuICAgIGNvbnN0IHVucmVnaXN0ZXIgPSAobmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgbmFtZSA/IGNvbnZlcnRUb0FycmF5UGF5bG9hZChuYW1lKSA6IF9uYW1lcy5tb3VudCkge1xyXG4gICAgICAgICAgICBfbmFtZXMubW91bnQuZGVsZXRlKGZpZWxkTmFtZSk7XHJcbiAgICAgICAgICAgIF9uYW1lcy5hcnJheS5kZWxldGUoZmllbGROYW1lKTtcclxuICAgICAgICAgICAgaWYgKGdldChfZmllbGRzLCBmaWVsZE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMua2VlcFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5zZXQoX2ZpZWxkcywgZmllbGROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB1bnNldChfZm9ybVZhbHVlcywgZmllbGROYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICFvcHRpb25zLmtlZXBFcnJvciAmJiB1bnNldChfZm9ybVN0YXRlLmVycm9ycywgZmllbGROYW1lKTtcclxuICAgICAgICAgICAgICAgICFvcHRpb25zLmtlZXBEaXJ0eSAmJiB1bnNldChfZm9ybVN0YXRlLmRpcnR5RmllbGRzLCBmaWVsZE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgIW9wdGlvbnMua2VlcFRvdWNoZWQgJiYgdW5zZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBmaWVsZE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgIV9vcHRpb25zLnNob3VsZFVucmVnaXN0ZXIgJiZcclxuICAgICAgICAgICAgICAgICAgICAhb3B0aW9ucy5rZWVwRGVmYXVsdFZhbHVlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdW5zZXQoX2RlZmF1bHRWYWx1ZXMsIGZpZWxkTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgX3N1YmplY3RzLnZhbHVlcy5uZXh0KHtcclxuICAgICAgICAgICAgdmFsdWVzOiB7IC4uLl9mb3JtVmFsdWVzIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xyXG4gICAgICAgICAgICAuLi5fZm9ybVN0YXRlLFxyXG4gICAgICAgICAgICAuLi4oIW9wdGlvbnMua2VlcERpcnR5ID8ge30gOiB7IGlzRGlydHk6IF9nZXREaXJ0eSgpIH0pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICFvcHRpb25zLmtlZXBJc1ZhbGlkICYmIF91cGRhdGVWYWxpZCgpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlZ2lzdGVyID0gKG5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xyXG4gICAgICAgIGxldCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcclxuICAgICAgICBjb25zdCBkaXNhYmxlZElzRGVmaW5lZCA9IGlzQm9vbGVhbihvcHRpb25zLmRpc2FibGVkKTtcclxuICAgICAgICBzZXQoX2ZpZWxkcywgbmFtZSwge1xyXG4gICAgICAgICAgICAuLi4oZmllbGQgfHwge30pLFxyXG4gICAgICAgICAgICBfZjoge1xyXG4gICAgICAgICAgICAgICAgLi4uKGZpZWxkICYmIGZpZWxkLl9mID8gZmllbGQuX2YgOiB7IHJlZjogeyBuYW1lIH0gfSksXHJcbiAgICAgICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICAgICAgbW91bnQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIF9uYW1lcy5tb3VudC5hZGQobmFtZSk7XHJcbiAgICAgICAgZmllbGRcclxuICAgICAgICAgICAgPyBkaXNhYmxlZElzRGVmaW5lZCAmJlxyXG4gICAgICAgICAgICAgICAgc2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBvcHRpb25zLmRpc2FibGVkXHJcbiAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICA6IGdldChfZm9ybVZhbHVlcywgbmFtZSwgZ2V0RmllbGRWYWx1ZShmaWVsZC5fZikpKVxyXG4gICAgICAgICAgICA6IHVwZGF0ZVZhbGlkQW5kVmFsdWUobmFtZSwgdHJ1ZSwgb3B0aW9ucy52YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4uKGRpc2FibGVkSXNEZWZpbmVkID8geyBkaXNhYmxlZDogb3B0aW9ucy5kaXNhYmxlZCB9IDoge30pLFxyXG4gICAgICAgICAgICAuLi4oX29wdGlvbnMuc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvblxyXG4gICAgICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICEhb3B0aW9ucy5yZXF1aXJlZCxcclxuICAgICAgICAgICAgICAgICAgICBtaW46IGdldFJ1bGVWYWx1ZShvcHRpb25zLm1pbiksXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4OiBnZXRSdWxlVmFsdWUob3B0aW9ucy5tYXgpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pbkxlbmd0aDogZ2V0UnVsZVZhbHVlKG9wdGlvbnMubWluTGVuZ3RoKSxcclxuICAgICAgICAgICAgICAgICAgICBtYXhMZW5ndGg6IGdldFJ1bGVWYWx1ZShvcHRpb25zLm1heExlbmd0aCksXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogZ2V0UnVsZVZhbHVlKG9wdGlvbnMucGF0dGVybiksXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA6IHt9KSxcclxuICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgb25DaGFuZ2UsXHJcbiAgICAgICAgICAgIG9uQmx1cjogb25DaGFuZ2UsXHJcbiAgICAgICAgICAgIHJlZjogKHJlZikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlZikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyKG5hbWUsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkUmVmID0gaXNVbmRlZmluZWQocmVmLnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlZi5xdWVyeVNlbGVjdG9yQWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJlZi5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCxzZWxlY3QsdGV4dGFyZWEnKVswXSB8fCByZWZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVmO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhZGlvT3JDaGVja2JveCA9IGlzUmFkaW9PckNoZWNrYm94KGZpZWxkUmVmKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWZzID0gZmllbGQuX2YucmVmcyB8fCBbXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmFkaW9PckNoZWNrYm94XHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVmcy5maW5kKChvcHRpb24pID0+IG9wdGlvbiA9PT0gZmllbGRSZWYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZmllbGRSZWYgPT09IGZpZWxkLl9mLnJlZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNldChfZmllbGRzLCBuYW1lLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5maWVsZC5fZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLihyYWRpb09yQ2hlY2tib3hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucmVmcy5maWx0ZXIobGl2ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFJlZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLihBcnJheS5pc0FycmF5KGdldChfZGVmYXVsdFZhbHVlcywgbmFtZSkpID8gW3t9XSA6IFtdKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiB7IHR5cGU6IGZpZWxkUmVmLnR5cGUsIG5hbWUgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7IHJlZjogZmllbGRSZWYgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmFsaWRBbmRWYWx1ZShuYW1lLCBmYWxzZSwgdW5kZWZpbmVkLCBmaWVsZFJlZik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lLCB7fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLl9mKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLl9mLm1vdW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIChfb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyIHx8IG9wdGlvbnMuc2hvdWxkVW5yZWdpc3RlcikgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgIShpc05hbWVJbkZpZWxkQXJyYXkoX25hbWVzLmFycmF5LCBuYW1lKSAmJiBfc3RhdGUuYWN0aW9uKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbmFtZXMudW5Nb3VudC5hZGQobmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBjb25zdCBfZm9jdXNFcnJvciA9ICgpID0+IF9vcHRpb25zLnNob3VsZEZvY3VzRXJyb3IgJiZcclxuICAgICAgICBmb2N1c0ZpZWxkQnkoX2ZpZWxkcywgKGtleSkgPT4ga2V5ICYmIGdldChfZm9ybVN0YXRlLmVycm9ycywga2V5KSwgX25hbWVzLm1vdW50KTtcclxuICAgIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IChvblZhbGlkLCBvbkludmFsaWQpID0+IGFzeW5jIChlKSA9PiB7XHJcbiAgICAgICAgaWYgKGUpIHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCAmJiBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGUucGVyc2lzdCAmJiBlLnBlcnNpc3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGZpZWxkVmFsdWVzID0gY2xvbmVPYmplY3QoX2Zvcm1WYWx1ZXMpO1xyXG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcclxuICAgICAgICAgICAgaXNTdWJtaXR0aW5nOiB0cnVlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChfb3B0aW9ucy5yZXNvbHZlcikge1xyXG4gICAgICAgICAgICBjb25zdCB7IGVycm9ycywgdmFsdWVzIH0gPSBhd2FpdCBfZXhlY3V0ZVNjaGVtYSgpO1xyXG4gICAgICAgICAgICBfZm9ybVN0YXRlLmVycm9ycyA9IGVycm9ycztcclxuICAgICAgICAgICAgZmllbGRWYWx1ZXMgPSB2YWx1ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhd2FpdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24oX2ZpZWxkcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCAncm9vdCcpO1xyXG4gICAgICAgIGlmIChpc0VtcHR5T2JqZWN0KF9mb3JtU3RhdGUuZXJyb3JzKSkge1xyXG4gICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XHJcbiAgICAgICAgICAgICAgICBlcnJvcnM6IHt9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgYXdhaXQgb25WYWxpZChmaWVsZFZhbHVlcywgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAob25JbnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBvbkludmFsaWQoeyAuLi5fZm9ybVN0YXRlLmVycm9ycyB9LCBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfZm9jdXNFcnJvcigpO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KF9mb2N1c0Vycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xyXG4gICAgICAgICAgICBpc1N1Ym1pdHRlZDogdHJ1ZSxcclxuICAgICAgICAgICAgaXNTdWJtaXR0aW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgaXNTdWJtaXRTdWNjZXNzZnVsOiBpc0VtcHR5T2JqZWN0KF9mb3JtU3RhdGUuZXJyb3JzKSxcclxuICAgICAgICAgICAgc3VibWl0Q291bnQ6IF9mb3JtU3RhdGUuc3VibWl0Q291bnQgKyAxLFxyXG4gICAgICAgICAgICBlcnJvcnM6IF9mb3JtU3RhdGUuZXJyb3JzLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlc2V0RmllbGQgPSAobmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XHJcbiAgICAgICAgaWYgKGdldChfZmllbGRzLCBuYW1lKSkge1xyXG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQob3B0aW9ucy5kZWZhdWx0VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRWYWx1ZShuYW1lLCBnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNldFZhbHVlKG5hbWUsIG9wdGlvbnMuZGVmYXVsdFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHNldChfZGVmYXVsdFZhbHVlcywgbmFtZSwgb3B0aW9ucy5kZWZhdWx0VmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5rZWVwVG91Y2hlZCkge1xyXG4gICAgICAgICAgICAgICAgdW5zZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMua2VlcERpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICB1bnNldChfZm9ybVN0YXRlLmRpcnR5RmllbGRzLCBuYW1lKTtcclxuICAgICAgICAgICAgICAgIF9mb3JtU3RhdGUuaXNEaXJ0eSA9IG9wdGlvbnMuZGVmYXVsdFZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgPyBfZ2V0RGlydHkobmFtZSwgZ2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lKSlcclxuICAgICAgICAgICAgICAgICAgICA6IF9nZXREaXJ0eSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5rZWVwRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcclxuICAgICAgICAgICAgICAgIF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkICYmIF91cGRhdGVWYWxpZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHsgLi4uX2Zvcm1TdGF0ZSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgX3Jlc2V0ID0gKGZvcm1WYWx1ZXMsIGtlZXBTdGF0ZU9wdGlvbnMgPSB7fSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRWYWx1ZXMgPSBmb3JtVmFsdWVzIHx8IF9kZWZhdWx0VmFsdWVzO1xyXG4gICAgICAgIGNvbnN0IGNsb25lVXBkYXRlZFZhbHVlcyA9IGNsb25lT2JqZWN0KHVwZGF0ZWRWYWx1ZXMpO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGZvcm1WYWx1ZXMgJiYgIWlzRW1wdHlPYmplY3QoZm9ybVZhbHVlcylcclxuICAgICAgICAgICAgPyBjbG9uZVVwZGF0ZWRWYWx1ZXNcclxuICAgICAgICAgICAgOiBfZGVmYXVsdFZhbHVlcztcclxuICAgICAgICBpZiAoIWtlZXBTdGF0ZU9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZXMpIHtcclxuICAgICAgICAgICAgX2RlZmF1bHRWYWx1ZXMgPSB1cGRhdGVkVmFsdWVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWtlZXBTdGF0ZU9wdGlvbnMua2VlcFZhbHVlcykge1xyXG4gICAgICAgICAgICBpZiAoa2VlcFN0YXRlT3B0aW9ucy5rZWVwRGlydHlWYWx1ZXMgfHwgc2hvdWxkQ2FwdHVyZURpcnR5RmllbGRzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBvZiBfbmFtZXMubW91bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBnZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgZmllbGROYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNldCh2YWx1ZXMsIGZpZWxkTmFtZSwgZ2V0KF9mb3JtVmFsdWVzLCBmaWVsZE5hbWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNldFZhbHVlKGZpZWxkTmFtZSwgZ2V0KHZhbHVlcywgZmllbGROYW1lKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNXZWIgJiYgaXNVbmRlZmluZWQoZm9ybVZhbHVlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgX25hbWVzLm1vdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQgJiYgZmllbGQuX2YpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkUmVmZXJlbmNlID0gQXJyYXkuaXNBcnJheShmaWVsZC5fZi5yZWZzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZmllbGQuX2YucmVmc1swXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZmllbGQuX2YucmVmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSFRNTEVsZW1lbnQoZmllbGRSZWZlcmVuY2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybSA9IGZpZWxkUmVmZXJlbmNlLmNsb3Nlc3QoJ2Zvcm0nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9ybSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF9maWVsZHMgPSB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfZm9ybVZhbHVlcyA9IHByb3BzLnNob3VsZFVucmVnaXN0ZXJcclxuICAgICAgICAgICAgICAgID8ga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGVmYXVsdFZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgID8gY2xvbmVPYmplY3QoX2RlZmF1bHRWYWx1ZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgOiB7fVxyXG4gICAgICAgICAgICAgICAgOiBjbG9uZVVwZGF0ZWRWYWx1ZXM7XHJcbiAgICAgICAgICAgIF9zdWJqZWN0cy5hcnJheS5uZXh0KHtcclxuICAgICAgICAgICAgICAgIHZhbHVlczogeyAuLi52YWx1ZXMgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIF9zdWJqZWN0cy52YWx1ZXMubmV4dCh7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHsgLi4udmFsdWVzIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfbmFtZXMgPSB7XHJcbiAgICAgICAgICAgIG1vdW50OiBuZXcgU2V0KCksXHJcbiAgICAgICAgICAgIHVuTW91bnQ6IG5ldyBTZXQoKSxcclxuICAgICAgICAgICAgYXJyYXk6IG5ldyBTZXQoKSxcclxuICAgICAgICAgICAgd2F0Y2g6IG5ldyBTZXQoKSxcclxuICAgICAgICAgICAgd2F0Y2hBbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICBmb2N1czogJycsXHJcbiAgICAgICAgfTtcclxuICAgICAgICAhX3N0YXRlLm1vdW50ICYmIGZsdXNoUm9vdFJlbmRlcigpO1xyXG4gICAgICAgIF9zdGF0ZS5tb3VudCA9ICFfcHJveHlGb3JtU3RhdGUuaXNWYWxpZCB8fCAhIWtlZXBTdGF0ZU9wdGlvbnMua2VlcElzVmFsaWQ7XHJcbiAgICAgICAgX3N0YXRlLndhdGNoID0gISFwcm9wcy5zaG91bGRVbnJlZ2lzdGVyO1xyXG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcclxuICAgICAgICAgICAgc3VibWl0Q291bnQ6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcFN1Ym1pdENvdW50XHJcbiAgICAgICAgICAgICAgICA/IF9mb3JtU3RhdGUuc3VibWl0Q291bnRcclxuICAgICAgICAgICAgICAgIDogMCxcclxuICAgICAgICAgICAgaXNEaXJ0eToga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGlydHlcclxuICAgICAgICAgICAgICAgID8gX2Zvcm1TdGF0ZS5pc0RpcnR5XHJcbiAgICAgICAgICAgICAgICA6ICEhKGtlZXBTdGF0ZU9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZXMgJiZcclxuICAgICAgICAgICAgICAgICAgICAhZGVlcEVxdWFsKGZvcm1WYWx1ZXMsIF9kZWZhdWx0VmFsdWVzKSksXHJcbiAgICAgICAgICAgIGlzU3VibWl0dGVkOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBJc1N1Ym1pdHRlZFxyXG4gICAgICAgICAgICAgICAgPyBfZm9ybVN0YXRlLmlzU3VibWl0dGVkXHJcbiAgICAgICAgICAgICAgICA6IGZhbHNlLFxyXG4gICAgICAgICAgICBkaXJ0eUZpZWxkczoga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGlydHlWYWx1ZXNcclxuICAgICAgICAgICAgICAgID8gX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkc1xyXG4gICAgICAgICAgICAgICAgOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBEZWZhdWx0VmFsdWVzICYmIGZvcm1WYWx1ZXNcclxuICAgICAgICAgICAgICAgICAgICA/IGdldERpcnR5RmllbGRzKF9kZWZhdWx0VmFsdWVzLCBmb3JtVmFsdWVzKVxyXG4gICAgICAgICAgICAgICAgICAgIDoge30sXHJcbiAgICAgICAgICAgIHRvdWNoZWRGaWVsZHM6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcFRvdWNoZWRcclxuICAgICAgICAgICAgICAgID8gX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzXHJcbiAgICAgICAgICAgICAgICA6IHt9LFxyXG4gICAgICAgICAgICBlcnJvcnM6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcEVycm9ycyA/IF9mb3JtU3RhdGUuZXJyb3JzIDoge30sXHJcbiAgICAgICAgICAgIGlzU3VibWl0dGluZzogZmFsc2UsXHJcbiAgICAgICAgICAgIGlzU3VibWl0U3VjY2Vzc2Z1bDogZmFsc2UsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVzZXQgPSAoZm9ybVZhbHVlcywga2VlcFN0YXRlT3B0aW9ucykgPT4gX3Jlc2V0KGlzRnVuY3Rpb24oZm9ybVZhbHVlcylcclxuICAgICAgICA/IGZvcm1WYWx1ZXMoX2Zvcm1WYWx1ZXMpXHJcbiAgICAgICAgOiBmb3JtVmFsdWVzLCBrZWVwU3RhdGVPcHRpb25zKTtcclxuICAgIGNvbnN0IHNldEZvY3VzID0gKG5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGZpZWxkUmVmZXJlbmNlID0gZmllbGQgJiYgZmllbGQuX2Y7XHJcbiAgICAgICAgaWYgKGZpZWxkUmVmZXJlbmNlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkUmVmID0gZmllbGRSZWZlcmVuY2UucmVmc1xyXG4gICAgICAgICAgICAgICAgPyBmaWVsZFJlZmVyZW5jZS5yZWZzWzBdXHJcbiAgICAgICAgICAgICAgICA6IGZpZWxkUmVmZXJlbmNlLnJlZjtcclxuICAgICAgICAgICAgaWYgKGZpZWxkUmVmLmZvY3VzKSB7XHJcbiAgICAgICAgICAgICAgICBmaWVsZFJlZi5mb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaG91bGRTZWxlY3QgJiYgZmllbGRSZWYuc2VsZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgX3VwZGF0ZUZvcm1TdGF0ZSA9ICh1cGRhdGVkRm9ybVN0YXRlKSA9PiB7XHJcbiAgICAgICAgX2Zvcm1TdGF0ZSA9IHtcclxuICAgICAgICAgICAgLi4uX2Zvcm1TdGF0ZSxcclxuICAgICAgICAgICAgLi4udXBkYXRlZEZvcm1TdGF0ZSxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIGlmIChpc0Z1bmN0aW9uKF9vcHRpb25zLmRlZmF1bHRWYWx1ZXMpKSB7XHJcbiAgICAgICAgX29wdGlvbnMuZGVmYXVsdFZhbHVlcygpLnRoZW4oKHZhbHVlcykgPT4ge1xyXG4gICAgICAgICAgICByZXNldCh2YWx1ZXMsIF9vcHRpb25zLnJlc2V0T3B0aW9ucyk7XHJcbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcclxuICAgICAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjb250cm9sOiB7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyLFxyXG4gICAgICAgICAgICB1bnJlZ2lzdGVyLFxyXG4gICAgICAgICAgICBnZXRGaWVsZFN0YXRlLFxyXG4gICAgICAgICAgICBfZXhlY3V0ZVNjaGVtYSxcclxuICAgICAgICAgICAgX2dldFdhdGNoLFxyXG4gICAgICAgICAgICBfZ2V0RGlydHksXHJcbiAgICAgICAgICAgIF91cGRhdGVWYWxpZCxcclxuICAgICAgICAgICAgX3JlbW92ZVVubW91bnRlZCxcclxuICAgICAgICAgICAgX3VwZGF0ZUZpZWxkQXJyYXksXHJcbiAgICAgICAgICAgIF9nZXRGaWVsZEFycmF5LFxyXG4gICAgICAgICAgICBfcmVzZXQsXHJcbiAgICAgICAgICAgIF91cGRhdGVGb3JtU3RhdGUsXHJcbiAgICAgICAgICAgIF9zdWJqZWN0cyxcclxuICAgICAgICAgICAgX3Byb3h5Rm9ybVN0YXRlLFxyXG4gICAgICAgICAgICBnZXQgX2ZpZWxkcygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfZmllbGRzO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXQgX2Zvcm1WYWx1ZXMoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX2Zvcm1WYWx1ZXM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldCBfc3RhdGUoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N0YXRlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQgX3N0YXRlKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBfc3RhdGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0IF9kZWZhdWx0VmFsdWVzKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9kZWZhdWx0VmFsdWVzO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXQgX25hbWVzKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9uYW1lcztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0IF9uYW1lcyh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgX25hbWVzID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldCBfZm9ybVN0YXRlKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mb3JtU3RhdGU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldCBfZm9ybVN0YXRlKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBfZm9ybVN0YXRlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldCBfb3B0aW9ucygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfb3B0aW9ucztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0IF9vcHRpb25zKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBfb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAuLi5fb3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0cmlnZ2VyLFxyXG4gICAgICAgIHJlZ2lzdGVyLFxyXG4gICAgICAgIGhhbmRsZVN1Ym1pdCxcclxuICAgICAgICB3YXRjaCxcclxuICAgICAgICBzZXRWYWx1ZSxcclxuICAgICAgICBnZXRWYWx1ZXMsXHJcbiAgICAgICAgcmVzZXQsXHJcbiAgICAgICAgcmVzZXRGaWVsZCxcclxuICAgICAgICBjbGVhckVycm9ycyxcclxuICAgICAgICB1bnJlZ2lzdGVyLFxyXG4gICAgICAgIHNldEVycm9yLFxyXG4gICAgICAgIHNldEZvY3VzLFxyXG4gICAgICAgIGdldEZpZWxkU3RhdGUsXHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBDdXN0b20gaG9vayB0byBtYW5hZ2UgdGhlIGVudGlyZSBmb3JtLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vYXBpL3VzZWZvcm0pIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS1nZXQtc3RhcnRlZC10cy01a3NtbSkg4oCiIFtWaWRlb10oaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1Sa1h2NEFYWENfNClcclxuICpcclxuICogQHBhcmFtIHByb3BzIC0gZm9ybSBjb25maWd1cmF0aW9uIGFuZCB2YWxpZGF0aW9uIHBhcmFtZXRlcnMuXHJcbiAqXHJcbiAqIEByZXR1cm5zIG1ldGhvZHMgLSBpbmRpdmlkdWFsIGZ1bmN0aW9ucyB0byBtYW5hZ2UgdGhlIGZvcm0gc3RhdGUuIHtAbGluayBVc2VGb3JtUmV0dXJufVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGB0c3hcclxuICogZnVuY3Rpb24gQXBwKCkge1xyXG4gKiAgIGNvbnN0IHsgcmVnaXN0ZXIsIGhhbmRsZVN1Ym1pdCwgd2F0Y2gsIGZvcm1TdGF0ZTogeyBlcnJvcnMgfSB9ID0gdXNlRm9ybSgpO1xyXG4gKiAgIGNvbnN0IG9uU3VibWl0ID0gZGF0YSA9PiBjb25zb2xlLmxvZyhkYXRhKTtcclxuICpcclxuICogICBjb25zb2xlLmxvZyh3YXRjaChcImV4YW1wbGVcIikpO1xyXG4gKlxyXG4gKiAgIHJldHVybiAoXHJcbiAqICAgICA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlU3VibWl0KG9uU3VibWl0KX0+XHJcbiAqICAgICAgIDxpbnB1dCBkZWZhdWx0VmFsdWU9XCJ0ZXN0XCIgey4uLnJlZ2lzdGVyKFwiZXhhbXBsZVwiKX0gLz5cclxuICogICAgICAgPGlucHV0IHsuLi5yZWdpc3RlcihcImV4YW1wbGVSZXF1aXJlZFwiLCB7IHJlcXVpcmVkOiB0cnVlIH0pfSAvPlxyXG4gKiAgICAgICB7ZXJyb3JzLmV4YW1wbGVSZXF1aXJlZCAmJiA8c3Bhbj5UaGlzIGZpZWxkIGlzIHJlcXVpcmVkPC9zcGFuPn1cclxuICogICAgICAgPGlucHV0IHR5cGU9XCJzdWJtaXRcIiAvPlxyXG4gKiAgICAgPC9mb3JtPlxyXG4gKiAgICk7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VGb3JtKHByb3BzID0ge30pIHtcclxuICAgIGNvbnN0IF9mb3JtQ29udHJvbCA9IFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS51c2VSZWYoKTtcclxuICAgIGNvbnN0IFtmb3JtU3RhdGUsIHVwZGF0ZUZvcm1TdGF0ZV0gPSBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0udXNlU3RhdGUoe1xyXG4gICAgICAgIGlzRGlydHk6IGZhbHNlLFxyXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXHJcbiAgICAgICAgaXNMb2FkaW5nOiB0cnVlLFxyXG4gICAgICAgIGlzU3VibWl0dGVkOiBmYWxzZSxcclxuICAgICAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlLFxyXG4gICAgICAgIGlzU3VibWl0U3VjY2Vzc2Z1bDogZmFsc2UsXHJcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXHJcbiAgICAgICAgc3VibWl0Q291bnQ6IDAsXHJcbiAgICAgICAgZGlydHlGaWVsZHM6IHt9LFxyXG4gICAgICAgIHRvdWNoZWRGaWVsZHM6IHt9LFxyXG4gICAgICAgIGVycm9yczoge30sXHJcbiAgICAgICAgZGVmYXVsdFZhbHVlczogaXNGdW5jdGlvbihwcm9wcy5kZWZhdWx0VmFsdWVzKVxyXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICA6IHByb3BzLmRlZmF1bHRWYWx1ZXMsXHJcbiAgICB9KTtcclxuICAgIGlmICghX2Zvcm1Db250cm9sLmN1cnJlbnQpIHtcclxuICAgICAgICBfZm9ybUNvbnRyb2wuY3VycmVudCA9IHtcclxuICAgICAgICAgICAgLi4uY3JlYXRlRm9ybUNvbnRyb2wocHJvcHMsICgpID0+IHVwZGF0ZUZvcm1TdGF0ZSgoZm9ybVN0YXRlKSA9PiAoeyAuLi5mb3JtU3RhdGUgfSkpKSxcclxuICAgICAgICAgICAgZm9ybVN0YXRlLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb250cm9sID0gX2Zvcm1Db250cm9sLmN1cnJlbnQuY29udHJvbDtcclxuICAgIGNvbnRyb2wuX29wdGlvbnMgPSBwcm9wcztcclxuICAgIHVzZVN1YnNjcmliZSh7XHJcbiAgICAgICAgc3ViamVjdDogY29udHJvbC5fc3ViamVjdHMuc3RhdGUsXHJcbiAgICAgICAgbmV4dDogKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRSZW5kZXJGb3JtU3RhdGUodmFsdWUsIGNvbnRyb2wuX3Byb3h5Rm9ybVN0YXRlLCBjb250cm9sLl91cGRhdGVGb3JtU3RhdGUsIHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVGb3JtU3RhdGUoeyAuLi5jb250cm9sLl9mb3JtU3RhdGUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcbiAgICBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0udXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAocHJvcHMudmFsdWVzICYmICFkZWVwRXF1YWwocHJvcHMudmFsdWVzLCBjb250cm9sLl9kZWZhdWx0VmFsdWVzKSkge1xyXG4gICAgICAgICAgICBjb250cm9sLl9yZXNldChwcm9wcy52YWx1ZXMsIGNvbnRyb2wuX29wdGlvbnMucmVzZXRPcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbcHJvcHMudmFsdWVzLCBjb250cm9sXSk7XHJcbiAgICBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0udXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoIWNvbnRyb2wuX3N0YXRlLm1vdW50KSB7XHJcbiAgICAgICAgICAgIGNvbnRyb2wuX3VwZGF0ZVZhbGlkKCk7XHJcbiAgICAgICAgICAgIGNvbnRyb2wuX3N0YXRlLm1vdW50ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbnRyb2wuX3N0YXRlLndhdGNoKSB7XHJcbiAgICAgICAgICAgIGNvbnRyb2wuX3N0YXRlLndhdGNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoeyAuLi5jb250cm9sLl9mb3JtU3RhdGUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRyb2wuX3JlbW92ZVVubW91bnRlZCgpO1xyXG4gICAgfSk7XHJcbiAgICBfZm9ybUNvbnRyb2wuY3VycmVudC5mb3JtU3RhdGUgPSBnZXRQcm94eUZvcm1TdGF0ZShmb3JtU3RhdGUsIGNvbnRyb2wpO1xyXG4gICAgcmV0dXJuIF9mb3JtQ29udHJvbC5jdXJyZW50O1xyXG59XG5cbnZhciBjb2xvcnMgPSB7XHJcbiAgICBwcmltYXJ5OiAnIzBlMTAxYycsXHJcbiAgICBzZWNvbmRhcnk6ICcjYmYxNjUwJyxcclxuICAgIGxpZ2h0Qmx1ZTogJyM1MTYzOTEnLFxyXG4gICAgYmx1ZTogJyMxZTJhNGEnLFxyXG4gICAgbGlnaHRQaW5rOiAnI2VjNTk5MCcsXHJcbiAgICBlcnJvclBpbms6ICcjZmJlY2YyJyxcclxuICAgIGJ1dHRvbkJsdWU6ICcjMTkxZDNhJyxcclxuICAgIGxpbms6ICcjZmY3YWE4JyxcclxuICAgIGdyZWVuOiAnIzFiZGEyYicsXHJcbn07XG5cbmNvbnN0IHBhcmFHcmFwaERlZmF1bHRTdHlsZSA9IHtcclxuICAgIGZvbnRTaXplOiAxMyxcclxuICAgIGxpbmVIZWlnaHQ6ICcyMHB4JyxcclxufTtcclxuY29uc3QgQnV0dG9uID0gc3R5bGVkX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5idXR0b24gYFxuICBhcHBlYXJhbmNlOiBub25lO1xuICBtYXJnaW46IDA7XG4gIGJvcmRlcjogMDtcbiAgY29sb3I6IHdoaXRlO1xuICBwYWRkaW5nOiA1cHggIWltcG9ydGFudDtcbiAgYm9yZGVyLXJhZGl1czogMCAhaW1wb3J0YW50O1xuICBiYWNrZ3JvdW5kOiAkeyhwcm9wcykgPT4gcHJvcHMuaGlkZUJhY2tncm91bmQgPyBgYCA6IGAke2NvbG9ycy5ibHVlfSAhaW1wb3J0YW50YH07XG4gIHRyYW5zaXRpb246IDAuMnMgYWxsO1xuXG4gICY6aG92ZXIge1xuICAgIGJhY2tncm91bmQ6ICR7Y29sb3JzLmxpZ2h0Qmx1ZX07XG4gIH1cbmA7XHJcbkJ1dHRvbi5kZWZhdWx0UHJvcHMgPSB7IHR5cGU6ICdidXR0b24nIH07XHJcbmNvbnN0IENpcmNsZUJ1dHRvbiA9IHN0eWxlZF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oQnV0dG9uKSBgXG4gIGZvbnQtc2l6ZTogMTRweDtcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gIG1hcmdpbjogMCA0cHggMCBhdXRvO1xuICBiYWNrZ3JvdW5kOiBub25lICFpbXBvcnRhbnQ7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIHdpZHRoOiAyNXB4O1xuICBoZWlnaHQ6IDI1cHg7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICBsaW5lLWhlaWdodDogMTRweCAhaW1wb3J0YW50O1xuICBib3JkZXItcmFkaXVzOiA1MCUgIWltcG9ydGFudDtcbiAgcGFkZGluZzogMCAhaW1wb3J0YW50O1xuICB0cmFuc2l0aW9uOiAwLjJzIGFsbDtcblxuICAmOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kOiAke2NvbG9ycy5saWdodEJsdWV9O1xuICB9XG5cbiAgJjphY3RpdmUge1xuICAgIGJhY2tncm91bmQ6IGJsYWNrO1xuICB9XG5gO1xyXG5jb25zdCBJbnB1dCA9IHN0eWxlZF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uaW5wdXQgYFxuICAmOjpwbGFjZWhvbGRlciB7XG4gICAgY29sb3I6ICNiM2IzYjM7XG4gIH1cblxuICAmOmZvY3VzOjpwbGFjZWhvbGRlciB7XG4gICAgY29sb3I6IHdoaXRlO1xuICB9XG5gO1xyXG5jb25zdCBUYWJsZSA9IHN0eWxlZF9fZGVmYXVsdFtcImRlZmF1bHRcIl0udGFibGUgYFxuICB0cmFuc2l0aW9uOiAwLjNzIGFsbDtcblxuICAmOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kOiAke2NvbG9ycy5wcmltYXJ5fTtcbiAgfVxuYDtcblxuY29uc3QgSGVhZGVyID0gKHsgc2V0VmlzaWJsZSwgY29udHJvbCB9KSA9PiB7XHJcbiAgICBjb25zdCB7IGlzVmFsaWQgfSA9IHVzZUZvcm1TdGF0ZSh7XHJcbiAgICAgICAgY29udHJvbCxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJoZWFkZXJcIiwgeyBzdHlsZToge1xyXG4gICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXHJcbiAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxyXG4gICAgICAgICAgICBwYWRkaW5nTGVmdDogMTAsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcclxuICAgICAgICB9IH0sXHJcbiAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicFwiLCB7IHN0eWxlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFHcmFwaERlZmF1bHRTdHlsZSksIHsgbWFyZ2luOiAwLCBwYWRkaW5nOiAwLCBmb250V2VpZ2h0OiA0MDAsIGZvbnRTaXplOiAxMiB9KSB9LFxyXG4gICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAnMC41cyBhbGwnLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBpc1ZhbGlkID8gY29sb3JzLmdyZWVuIDogY29sb3JzLmxpZ2h0UGluayxcclxuICAgICAgICAgICAgICAgIH0gfSwgXCJcXHUyNUEwXCIpLFxyXG4gICAgICAgICAgICAnICcsXHJcbiAgICAgICAgICAgIFwiUmVhY3QgSG9vayBGb3JtXCIpLFxyXG4gICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChDaXJjbGVCdXR0b24sIHsgdGl0bGU6IFwiQ2xvc2UgZGV2IHBhbmVsXCIsIG9uQ2xpY2s6ICgpID0+IHNldFZpc2libGUoZmFsc2UpIH0sIFwiXFx1MjcxNVwiKSkpO1xyXG59O1xuXG5jb25zdCBQYW5lbFRhYmxlID0gKHsgcmVmT2JqZWN0LCBoYXNFcnJvciwgaXNEaXJ0eSwgZmllbGRzVmFsdWVzLCBpc05hdGl2ZSwgZXJyb3JNZXNzYWdlLCBlcnJvclR5cGUsIHR5cGUsIGlzVG91Y2hlZCwgbmFtZSwgY29sbGFwc2VBbGwsIH0pID0+IHtcclxuICAgIGNvbnN0IFtjb2xsYXBzZSwgc2V0Q29sbGFwc2VdID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgc2V0Q29sbGFwc2UoIWNvbGxhcHNlQWxsKTtcclxuICAgIH0sIFtjb2xsYXBzZUFsbF0pO1xyXG4gICAgbGV0IHZhbHVlID0gZmllbGRzVmFsdWVzID8gZ2V0KGZpZWxkc1ZhbHVlcywgbmFtZSkgOiAnJztcclxuICAgIGxldCBpc1ZhbHVlV3JhcHBlZEluUHJlID0gZmFsc2U7XHJcbiAgICBpZiAoIWlzVW5kZWZpbmVkX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh2YWx1ZSkpIHtcclxuICAgICAgICBpZiAoaXNPYmplY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHZhbHVlKSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicHJlXCIsIHsgc3R5bGU6IHsgbWFyZ2luOiAwIH0gfSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIHsgc3R5bGU6IHsgZm9udFNpemU6IDEyIH0gfSwgSlNPTi5zdHJpbmdpZnkodmFsdWUsIG51bGwsIDIpKSkpO1xyXG4gICAgICAgICAgICAgICAgaXNWYWx1ZVdyYXBwZWRJblByZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgXCJbTmVzdGVkIE9iamVjdF1cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoVGFibGUsIHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgcGFkZGluZzogJzVweCA4cHgnLFxyXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAnLjNzIGFsbCcsXHJcbiAgICAgICAgICAgIGJvcmRlckxlZnQ6IGAycHggc29saWQgJHtoYXNFcnJvciA/IGNvbG9ycy5zZWNvbmRhcnkgOiBjb2xvcnMuYnV0dG9uQmx1ZX1gLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiAnbm9uZScsXHJcbiAgICAgICAgfSB9LFxyXG4gICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInRoZWFkXCIsIG51bGwsXHJcbiAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInRyXCIsIG51bGwsXHJcbiAgICAgICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IHZhbGlnbjogXCJ0b3BcIiwgc3R5bGU6IHsgd2lkdGg6IDg1LCBsaW5lSGVpZ2h0OiAnMjJweCcgfSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChCdXR0b24sIHsgb25DbGljazogKCkgPT4gc2V0Q29sbGFwc2UoIWNvbGxhcHNlKSwgdGl0bGU6IFwiVG9nZ2xlIGZpZWxkIHRhYmxlXCIsIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6IGAxcHggc29saWQgJHtjb2xvcnMubGlnaHRCbHVlfWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAnM3B4IDVweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiA5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodDogJzEzcHgnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDIwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiA4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IH0sIGNvbGxhcHNlID8gJysnIDogJy0nKSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQnV0dG9uLCB7IG9uQ2xpY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWZPYmplY3Quc2Nyb2xsSW50b1ZpZXcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZPYmplY3Quc2Nyb2xsSW50b1ZpZXcoeyBiZWhhdmlvcjogJ3Ntb290aCcgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRpdGxlOiBcIlNjcm9sbCBpbnRvIHZpZXdcIiwgc3R5bGU6IE9iamVjdC5hc3NpZ24oeyBib3JkZXI6IGAxcHggc29saWQgJHtjb2xvcnMubGlnaHRCbHVlfWAsIGJvcmRlclJhZGl1czogMiwgcGFkZGluZzogJzNweCA1cHgnLCBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJywgZm9udFNpemU6IDksIGxpbmVIZWlnaHQ6ICcxM3B4JywgdGV4dEFsaWduOiAnY2VudGVyJywgd2lkdGg6ICdjYWxjKDEwMCUgLSAzMHB4KScgfSwgKGlzTmF0aXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHt9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHsgY3Vyc29yOiAnbm90LWFsbG93ZWQnLCBiYWNrZ3JvdW5kOiBjb2xvcnMubGlnaHRCbHVlIH0pKSB9LCBpc05hdGl2ZSA/ICdOYXRpdmUnIDogJ0N1c3RvbScpKSxcclxuICAgICAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInRkXCIsIHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGg6IDE0MCxcclxuICAgICAgICAgICAgICAgICAgICB9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicFwiLCB7IHN0eWxlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBtYXJnaW46IDAsIHBhZGRpbmc6IDAsIHRvcDogMCwgcG9zaXRpb246ICdyZWxhdGl2ZScsIHdoaXRlU3BhY2U6ICdub3dyYXAnLCBvdmVyZmxvdzogJ2hpZGRlbicsIHRleHRPdmVyZmxvdzogJ2VsbGlwc2lzJyB9LCBwYXJhR3JhcGhEZWZhdWx0U3R5bGUpLCB7IGxpbmVIZWlnaHQ6ICcyNHB4JyB9KSwgdGl0bGU6IG5hbWUgfSwgbmFtZSkpKSksXHJcbiAgICAgICAgIWNvbGxhcHNlICYmIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJ0Ym9keVwiLCBudWxsLFxyXG4gICAgICAgICAgICB0eXBlICYmIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBhbGlnbjogXCJyaWdodFwiLCBzdHlsZTogT2JqZWN0LmFzc2lnbih7IHBhZGRpbmdSaWdodDogNSwgZm9udFdlaWdodDogNTAwLCB2ZXJ0aWNhbEFsaWduOiAndG9wJyB9LCBwYXJhR3JhcGhEZWZhdWx0U3R5bGUpIH0sIFwiVHlwZTpcIiksXHJcbiAgICAgICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IHN0eWxlOiBPYmplY3QuYXNzaWduKHsgZGlzcGxheTogJ2Jsb2NrJywgbWF4V2lkdGg6IDEwMCB9LCBwYXJhR3JhcGhEZWZhdWx0U3R5bGUpIH0sIHR5cGUpKSksXHJcbiAgICAgICAgICAgIGVycm9yVHlwZSAmJiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwidHJcIiwgbnVsbCxcclxuICAgICAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInRkXCIsIHsgYWxpZ246IFwicmlnaHRcIiwgc3R5bGU6IE9iamVjdC5hc3NpZ24oeyBwYWRkaW5nUmlnaHQ6IDUsIGZvbnRXZWlnaHQ6IDUwMCwgdmVydGljYWxBbGlnbjogJ3RvcCcgfSwgcGFyYUdyYXBoRGVmYXVsdFN0eWxlKSB9LCBcIkVSUk9SIFR5cGU6XCIpLFxyXG4gICAgICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBzdHlsZTogT2JqZWN0LmFzc2lnbih7IGRpc3BsYXk6ICdibG9jaycsIG1heFdpZHRoOiAxMDAgfSwgcGFyYUdyYXBoRGVmYXVsdFN0eWxlKSB9LCBlcnJvclR5cGUpKSksXHJcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSAmJiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwidHJcIiwgbnVsbCxcclxuICAgICAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInRkXCIsIHsgYWxpZ246IFwicmlnaHRcIiwgc3R5bGU6IE9iamVjdC5hc3NpZ24oeyBwYWRkaW5nUmlnaHQ6IDUsIGZvbnRXZWlnaHQ6IDUwMCwgdmVydGljYWxBbGlnbjogJ3RvcCcgfSwgcGFyYUdyYXBoRGVmYXVsdFN0eWxlKSB9LCBcIk1FU1NBR0U6XCIpLFxyXG4gICAgICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBzdHlsZTogT2JqZWN0LmFzc2lnbih7IGRpc3BsYXk6ICdibG9jaycsIG1heFdpZHRoOiAxMDAgfSwgcGFyYUdyYXBoRGVmYXVsdFN0eWxlKSB9LCB0eXBlb2YgZXJyb3JNZXNzYWdlID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICAgICAgICAgID8gZXJyb3JNZXNzYWdlLnRyaW0oKVxyXG4gICAgICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoZXJyb3JNZXNzYWdlKSkpKSxcclxuICAgICAgICAgICAgIWlzVW5kZWZpbmVkX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh2YWx1ZSkgJiYgKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInRyXCIsIG51bGwsXHJcbiAgICAgICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGFsaWduOiBcInJpZ2h0XCIsIHN0eWxlOiBPYmplY3QuYXNzaWduKHsgcGFkZGluZ1JpZ2h0OiA1LCBmb250V2VpZ2h0OiA1MDAsIHZlcnRpY2FsQWxpZ246ICd0b3AnIH0sIHBhcmFHcmFwaERlZmF1bHRTdHlsZSkgfSwgXCJWYWx1ZTpcIiksXHJcbiAgICAgICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IFwiZGF0YS10ZXN0aWRcIjogYCR7bmFtZX0tZmllbGQtdmFsdWVgLCBzdHlsZTogT2JqZWN0LmFzc2lnbih7IGRpc3BsYXk6ICdibG9jaycsIG1heFdpZHRoOiAxMDAgfSwgcGFyYUdyYXBoRGVmYXVsdFN0eWxlKSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICFpc1ZhbHVlV3JhcHBlZEluUHJlICYmIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwXCIsIHsgdGl0bGU6IHZhbHVlLCBzdHlsZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhR3JhcGhEZWZhdWx0U3R5bGUpLCB7IG1hcmdpbjogMCwgcGFkZGluZzogMCB9KSB9LCB2YWx1ZSkpLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzVmFsdWVXcmFwcGVkSW5QcmUgJiYgKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFHcmFwaERlZmF1bHRTdHlsZSksIHsgbWFyZ2luOiAwLCBwYWRkaW5nOiAwIH0pIH0sIHZhbHVlKSkpKSksXHJcbiAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInRyXCIsIG51bGwsXHJcbiAgICAgICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGFsaWduOiBcInJpZ2h0XCIsIHN0eWxlOiBPYmplY3QuYXNzaWduKHsgcGFkZGluZ1JpZ2h0OiA1LCBmb250V2VpZ2h0OiA1MDAsIHZlcnRpY2FsQWxpZ246ICd0b3AnIH0sIHBhcmFHcmFwaERlZmF1bHRTdHlsZSkgfSwgXCJUb3VjaGVkOlwiKSxcclxuICAgICAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInRkXCIsIG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCB7IHN0eWxlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBjb2xvcjogaXNUb3VjaGVkID8gY29sb3JzLmdyZWVuIDogY29sb3JzLmxpZ2h0UGluayB9LCBwYXJhR3JhcGhEZWZhdWx0U3R5bGUpLCB7IGZvbnRTaXplOiAxMiB9KSB9LCBpc1RvdWNoZWQgPyAndHJ1ZScgOiAnZmFsc2UnKSkpLFxyXG4gICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBhbGlnbjogXCJyaWdodFwiLCBzdHlsZTogT2JqZWN0LmFzc2lnbih7IHBhZGRpbmdSaWdodDogNSwgZm9udFdlaWdodDogNTAwLCB2ZXJ0aWNhbEFsaWduOiAndG9wJyB9LCBwYXJhR3JhcGhEZWZhdWx0U3R5bGUpIH0sIFwiRGlydHk6XCIpLFxyXG4gICAgICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwidGRcIiwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIHsgc3R5bGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGNvbG9yOiBpc0RpcnR5ID8gY29sb3JzLmdyZWVuIDogY29sb3JzLmxpZ2h0UGluayB9LCBwYXJhR3JhcGhEZWZhdWx0U3R5bGUpLCB7IGZvbnRTaXplOiAxMiB9KSB9LCBpc0RpcnR5ID8gJ3RydWUnIDogJ2ZhbHNlJykpKSkpKSk7XHJcbn07XG5cbmNvbnN0IEZvcm1TdGF0ZVRhYmxlID0gKHsgZm9ybVN0YXRlLCBzaG93Rm9ybVN0YXRlLCBzZXRTaG93Rm9ybVN0YXRlLCB9KSA9PiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHtcclxuICAgICAgICBhbGlnblNlbGY6ICdlbmQnLFxyXG4gICAgfSB9LFxyXG4gICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KHJlYWN0U2ltcGxlQW5pbWF0ZS5BbmltYXRlLCB7IHBsYXk6IHNob3dGb3JtU3RhdGUsIHN0YXJ0OiB7IG9wYWNpdHk6IDAgfSwgZW5kOiB7IG9wYWNpdHk6IDEgfSwgcmVuZGVyOiAoeyBzdHlsZSB9KSA9PiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwidGFibGVcIiwgeyBzdHlsZTogT2JqZWN0LmFzc2lnbih7IHBhZGRpbmc6ICc1cHggMTBweCcsIGRpc3BsYXk6ICdibG9jaycsIGJhY2tncm91bmQ6ICdibGFjaycsIGJvcmRlclRvcDogYDFweCBzb2xpZCAke2NvbG9ycy5saWdodFBpbmt9YCwgcG9pbnRlckV2ZW50czogJ25vbmUnIH0sIHN0eWxlKSB9LFxyXG4gICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJ0Ym9keVwiLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwidHJcIiwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGFsaWduOiBcInJpZ2h0XCIsIHN0eWxlOiBPYmplY3QuYXNzaWduKHsgd2lkdGg6IDkwIH0sIHBhcmFHcmFwaERlZmF1bHRTdHlsZSkgfSwgXCJWYWxpZDpcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBzdHlsZTogT2JqZWN0LmFzc2lnbih7IGNvbG9yOiBmb3JtU3RhdGUuaXNWYWxpZCA/IGNvbG9ycy5ncmVlbiA6IGNvbG9ycy5saWdodFBpbmsgfSwgcGFyYUdyYXBoRGVmYXVsdFN0eWxlKSB9LCBmb3JtU3RhdGUuaXNWYWxpZCA/ICd0cnVlJyA6ICdmYWxzZScpKSxcclxuICAgICAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInRyXCIsIG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBhbGlnbjogXCJyaWdodFwiLCBzdHlsZTogT2JqZWN0LmFzc2lnbih7fSwgcGFyYUdyYXBoRGVmYXVsdFN0eWxlKSB9LCBcIkRpcnR5OlwiKSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IHN0eWxlOiBPYmplY3QuYXNzaWduKHsgY29sb3I6IGZvcm1TdGF0ZS5pc0RpcnR5ID8gY29sb3JzLmdyZWVuIDogY29sb3JzLmxpZ2h0UGluayB9LCBwYXJhR3JhcGhEZWZhdWx0U3R5bGUpIH0sIGZvcm1TdGF0ZS5pc0RpcnR5ID8gJ3RydWUnIDogJ2ZhbHNlJykpLFxyXG4gICAgICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwidHJcIiwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGFsaWduOiBcInJpZ2h0XCIsIHN0eWxlOiBPYmplY3QuYXNzaWduKHt9LCBwYXJhR3JhcGhEZWZhdWx0U3R5bGUpIH0sIFwiU3VibWl0dGVkOlwiKSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IHN0eWxlOiBPYmplY3QuYXNzaWduKHsgY29sb3I6IGZvcm1TdGF0ZS5pc1N1Ym1pdHRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY29sb3JzLmdyZWVuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjb2xvcnMubGlnaHRQaW5rIH0sIHBhcmFHcmFwaERlZmF1bHRTdHlsZSkgfSwgZm9ybVN0YXRlLmlzU3VibWl0dGVkID8gJ3RydWUnIDogJ2ZhbHNlJykpLFxyXG4gICAgICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwidHJcIiwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGFsaWduOiBcInJpZ2h0XCIsIHN0eWxlOiBPYmplY3QuYXNzaWduKHt9LCBwYXJhR3JhcGhEZWZhdWx0U3R5bGUpIH0sIFwiQ291bnQ6XCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInRkXCIsIHsgc3R5bGU6IE9iamVjdC5hc3NpZ24oeyBjb2xvcjogZm9ybVN0YXRlLnN1Ym1pdENvdW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjb2xvcnMuZ3JlZW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNvbG9ycy5saWdodFBpbmsgfSwgcGFyYUdyYXBoRGVmYXVsdFN0eWxlKSB9LCBmb3JtU3RhdGUuc3VibWl0Q291bnQpKSxcclxuICAgICAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInRyXCIsIG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBhbGlnbjogXCJyaWdodFwiLCBzdHlsZTogT2JqZWN0LmFzc2lnbih7fSwgcGFyYUdyYXBoRGVmYXVsdFN0eWxlKSB9LCBcIlN1Ym1pdHRpbmc6XCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInRkXCIsIHsgc3R5bGU6IE9iamVjdC5hc3NpZ24oeyBjb2xvcjogZm9ybVN0YXRlLmlzU3VibWl0dGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY29sb3JzLmdyZWVuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjb2xvcnMubGlnaHRQaW5rIH0sIHBhcmFHcmFwaERlZmF1bHRTdHlsZSkgfSwgZm9ybVN0YXRlLmlzU3VibWl0dGluZyA/ICd0cnVlJyA6ICdmYWxzZScpKSkpKSB9KSxcclxuICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChCdXR0b24sIHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgbWFyZ2luOiAwLFxyXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgICAgICAgICBwYWRkaW5nOiAnOHB4IDEwcHgnLFxyXG4gICAgICAgICAgICB0ZXh0VHJhbnNmb3JtOiAnbm9uZScsXHJcbiAgICAgICAgICAgIGZvbnRTaXplOiAxMixcclxuICAgICAgICAgICAgbGluZUhlaWdodDogJzE0cHgnLFxyXG4gICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJyxcclxuICAgICAgICB9LCB0aXRsZTogXCJUb2dnbGUgZm9ybSBzdGF0ZSBwYW5lbFwiLCBvbkNsaWNrOiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHNldFNob3dGb3JtU3RhdGUoIXNob3dGb3JtU3RhdGUpO1xyXG4gICAgICAgIH0gfSxcclxuICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICcwLjVzIGFsbCcsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogZm9ybVN0YXRlLmlzVmFsaWQgPyBjb2xvcnMuZ3JlZW4gOiBjb2xvcnMubGlnaHRQaW5rLFxyXG4gICAgICAgICAgICB9IH0sIFwiXFx1MjVBMFwiKSxcclxuICAgICAgICAnICcsXHJcbiAgICAgICAgXCJGb3JtIFN0YXRlOiBcIixcclxuICAgICAgICBzaG93Rm9ybVN0YXRlID8gJ09GRicgOiAnT04nKSkpO1xuXG5mdW5jdGlvbiBzZXRWaXNpYmxlKHN0YXRlLCBwYXlsb2FkKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHsgdmlzaWJsZTogcGF5bG9hZCB9KTtcclxufVxyXG5mdW5jdGlvbiBzZXRDb2xsYXBzZShzdGF0ZSwgcGF5bG9hZCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7IGlzQ29sbGFwc2U6IHBheWxvYWQgfSk7XHJcbn1cblxubGV0IGNoaWxkSW5kZXggPSAwO1xyXG5mdW5jdGlvbiBQYW5lbENoaWxkcmVuKHsgZmllbGRzLCBzZWFyY2hUZXJtLCB0b3VjaGVkRmllbGRzLCBlcnJvcnMsIGRpcnR5RmllbGRzLCBzdGF0ZSwgZmllbGRzVmFsdWVzLCB9KSB7XHJcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCBudWxsLCBmaWVsZHMgJiZcclxuICAgICAgICBPYmplY3QuZW50cmllcyhmaWVsZHMpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoKFtuYW1lXSkgPT4gKChuYW1lICYmXHJcbiAgICAgICAgICAgIG5hbWUudG9Mb3dlckNhc2UgJiZcclxuICAgICAgICAgICAgbmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaFRlcm0pKSB8fFxyXG4gICAgICAgICAgICAoIW5hbWUgJiYgIXNlYXJjaFRlcm0pIHx8XHJcbiAgICAgICAgICAgIHNlYXJjaFRlcm0gPT09ICcnKSAmJlxyXG4gICAgICAgICAgICBuYW1lKVxyXG4gICAgICAgICAgICAubWFwKChbbmFtZSwgdmFsdWVdLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBjaGlsZEluZGV4Kys7XHJcbiAgICAgICAgICAgIGlmICghKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS5fZikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFBhbmVsQ2hpbGRyZW4sIE9iamVjdC5hc3NpZ24oeyBrZXk6IG5hbWUgKyBjaGlsZEluZGV4IH0sIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaFRlcm0sXHJcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hlZEZpZWxkcyxcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgZGlydHlGaWVsZHMsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzVmFsdWVzLFxyXG4gICAgICAgICAgICAgICAgfSkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZ2V0KGVycm9ycywgdmFsdWUuX2YubmFtZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBnZXQoZXJyb3IsICdtZXNzYWdlJywgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yVHlwZSA9IGdldChlcnJvciwgJ3R5cGUnLCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGdldCh2YWx1ZSwgJ3JlZi50eXBlJywgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzVG91Y2hlZCA9ICEhZ2V0KHRvdWNoZWRGaWVsZHMsIHZhbHVlLl9mLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNOYXRpdmUgPSAhISh2YWx1ZSAmJiB2YWx1ZS5fZi5yZWYudHlwZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc0RpcnR5ID0gISFnZXQoZGlydHlGaWVsZHMsIHZhbHVlLl9mLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaGFzRXJyb3IgPSAhIWVycm9yO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVmID0gZ2V0KHZhbHVlLCAnX2YucmVmJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwgeyBrZXk6ICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUuX2YubmFtZSkgKyBjaGlsZEluZGV4LCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IGAxcHggZGFzaGVkICR7Y29sb3JzLnNlY29uZGFyeX1gLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgfSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChQYW5lbFRhYmxlLCB7IHJlZk9iamVjdDogcmVmLCBpbmRleDogaW5kZXgsIGNvbGxhcHNlQWxsOiBzdGF0ZS5pc0NvbGxhcHNlLCBuYW1lOiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUuX2YubmFtZSwgaXNUb3VjaGVkOiBpc1RvdWNoZWQsIHR5cGU6IHR5cGUsIGhhc0Vycm9yOiBoYXNFcnJvciwgaXNOYXRpdmU6IGlzTmF0aXZlLCBlcnJvck1lc3NhZ2U6IGVycm9yTWVzc2FnZSwgZXJyb3JUeXBlOiBlcnJvclR5cGUsIGlzRGlydHk6IGlzRGlydHksIGZpZWxkc1ZhbHVlczogZmllbGRzVmFsdWVzIH0pKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSkpO1xyXG59XHJcbmNvbnN0IFBhbmVsID0gKHsgY29udHJvbCwgY29udHJvbDogeyBfZmllbGRzIH0gfSkgPT4ge1xyXG4gICAgY29uc3QgZm9ybVN0YXRlID0gdXNlRm9ybVN0YXRlKHtcclxuICAgICAgICBjb250cm9sLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCB7IGRpcnR5RmllbGRzLCB0b3VjaGVkRmllbGRzLCBlcnJvcnMgfSA9IGZvcm1TdGF0ZTtcclxuICAgIGZvcm1TdGF0ZS5pc0RpcnR5O1xyXG4gICAgY29uc3QgeyBzdGF0ZSwgYWN0aW9ucyB9ID0gbGl0dGxlU3RhdGVNYWNoaW5lLnVzZVN0YXRlTWFjaGluZSh7XHJcbiAgICAgICAgc2V0Q29sbGFwc2UsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IFssIHNldERhdGFdID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZSh7fSk7XHJcbiAgICBjb25zdCBbc2hvd0Zvcm1TdGF0ZSwgc2V0U2hvd0Zvcm1TdGF0ZV0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IGZpZWxkc1ZhbHVlcyA9IHVzZVdhdGNoKHtcclxuICAgICAgICBjb250cm9sLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCB7IHJlZ2lzdGVyLCB3YXRjaCB9ID0gdXNlRm9ybSgpO1xyXG4gICAgY29uc3Qgc2VhcmNoVGVybSA9IHdhdGNoKCdzZWFyY2gnLCAnJyk7XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHNldERhdGEoe30pO1xyXG4gICAgfSwgW10pO1xyXG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZToge1xyXG4gICAgICAgICAgICBkaXNwbGF5OiAnZ3JpZCcsXHJcbiAgICAgICAgICAgIGdyaWRUZW1wbGF0ZVJvd3M6ICc1NnB4IGF1dG8nLFxyXG4gICAgICAgICAgICBoZWlnaHQ6ICdjYWxjKDEwMHZoIC0gNDBweCknLFxyXG4gICAgICAgIH0gfSxcclxuICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2dyaWQnLFxyXG4gICAgICAgICAgICAgICAgZ3JpZFRlbXBsYXRlQ29sdW1uczogYDFmciAxZnJgLFxyXG4gICAgICAgICAgICAgICAgZ3JpZFRlbXBsYXRlUm93czogJzI4cHggMjhweCcsXHJcbiAgICAgICAgICAgIH0gfSxcclxuICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEJ1dHRvbiwgeyBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlclJpZ2h0OiBgMXB4IHNvbGlkICR7Y29sb3JzLnByaW1hcnl9YCxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0VHJhbnNmb3JtOiAnbm9uZScsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IDExLFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IDEsXHJcbiAgICAgICAgICAgICAgICB9LCB0aXRsZTogXCJVcGRhdGUgdmFsdWVzIGFuZCBzdGF0ZSB0aGUgZm9ybVwiLCBvbkNsaWNrOiAoKSA9PiBzZXREYXRhKHt9KSB9LCBcIlxcdTI2N0EgUkVGUkVTSFwiKSxcclxuICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEJ1dHRvbiwgeyBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlclJpZ2h0OiBgMXB4IHNvbGlkICR7Y29sb3JzLnByaW1hcnl9YCxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0VHJhbnNmb3JtOiAnbm9uZScsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IDExLFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IDEsXHJcbiAgICAgICAgICAgICAgICB9LCB0aXRsZTogXCJUb2dnbGUgZW50aXJlIGZpZWxkc1wiLCBvbkNsaWNrOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9ucy5zZXRDb2xsYXBzZSghc3RhdGUuaXNDb2xsYXBzZSk7XHJcbiAgICAgICAgICAgICAgICB9IH0sIHN0YXRlLmlzQ29sbGFwc2UgPyAnWy1dIENPTExBUFNFJyA6ICdbK10gRVhQQU5EJyksXHJcbiAgICAgICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChJbnB1dCwgT2JqZWN0LmFzc2lnbih7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICc1cHggMTBweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgV2Via2l0QXBwZWFyYW5jZTogJ25vbmUnLFxyXG4gICAgICAgICAgICAgICAgICAgIGFwcGVhcmFuY2U6ICdub25lJyxcclxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogMTQsXHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxyXG4gICAgICAgICAgICAgICAgICAgIGdyaWRDb2x1bW5TdGFydDogMSxcclxuICAgICAgICAgICAgICAgICAgICBncmlkQ29sdW1uRW5kOiA0LFxyXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICdibGFjaycsXHJcbiAgICAgICAgICAgICAgICB9IH0sIHJlZ2lzdGVyKCdzZWFyY2gnKSwgeyBwbGFjZWhvbGRlcjogXCJGaWx0ZXIgbmFtZS4uLlwiLCB0eXBlOiBcInNlYXJjaFwiIH0pKSksXHJcbiAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnYXV0bycsXHJcbiAgICAgICAgICAgIH0gfSxcclxuICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFBhbmVsQ2hpbGRyZW4sIHsgZmllbGRzOiBfZmllbGRzLCBzZWFyY2hUZXJtOiBzZWFyY2hUZXJtLCBlcnJvcnM6IGVycm9ycywgdG91Y2hlZEZpZWxkczogdG91Y2hlZEZpZWxkcywgZGlydHlGaWVsZHM6IGRpcnR5RmllbGRzLCBmaWVsZHNWYWx1ZXM6IGZpZWxkc1ZhbHVlcywgc3RhdGU6IHN0YXRlIH0pKSxcclxuICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoRm9ybVN0YXRlVGFibGUsIHsgZm9ybVN0YXRlOiBmb3JtU3RhdGUsIHNob3dGb3JtU3RhdGU6IHNob3dGb3JtU3RhdGUsIHNldFNob3dGb3JtU3RhdGU6IHNldFNob3dGb3JtU3RhdGUgfSkpKTtcclxufTtcblxuY29uc3QgTG9nbyA9ICh7IHN0eWxlLCBhY3Rpb25zLCB9KSA9PiB7XHJcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IGZpbGw6IFwid2hpdGVcIiwgdmlld0JveDogXCIwIDAgMTAwIDEwMFwiLCBzdHlsZTogT2JqZWN0LmFzc2lnbih7IGhlaWdodDogMTQsIHBhZGRpbmc6IDMsIGJvcmRlclJhZGl1czogMiwgYmFja2dyb3VuZDogY29sb3JzLmxpZ2h0UGluayB9LCBzdHlsZSksIG9uQ2xpY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgYWN0aW9ucy5zZXRWaXNpYmxlKHRydWUpO1xyXG4gICAgICAgIH0sIFwiYXJpYS1sYWJlbFwiOiBcIlJlYWN0IEhvb2sgRm9ybSBMb2dvXCIgfSxcclxuICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNNzMuNTYsMTMuMzJINTguMTRhOC41NCw4LjU0LDAsMCwwLTE2LjI3LDBIMjYuNDRhMTEsMTEsMCwwLDAtMTEsMTFWODEuNjNhMTEsMTEsMCwwLDAsMTEsMTFINzMuNTZhMTEsMTEsMCwwLDAsMTEtMTFWMjQuMzJBMTEsMTEsMCwwLDAsNzMuNTYsMTMuMzJabS0zMC45MiwyYTEsMSwwLDAsMCwxLS43OSw2LjU0LDYuNTQsMCwwLDEsMTIuNzgsMCwxLDEsMCwwLDAsMSwuNzloNS4zOHY2LjU1YTMsMywwLDAsMS0zLDNINDAuMjVhMywzLDAsMCwxLTMtM1YxNS4zMlpNODIuNTYsODEuNjNhOSw5LDAsMCwxLTksOUgyNi40NGE5LDksMCwwLDEtOS05VjI0LjMyYTksOSwwLDAsMSw5LTloOC44MXY2LjU1YTUsNSwwLDAsMCw1LDVoMTkuNWE1LDUsMCwwLDAsNS01VjE1LjMyaDguODFhOSw5LDAsMCwxLDksOVpcIiB9KSxcclxuICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgc3R5bGU6IHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtMjVweCknIH0sIGQ6IFwiTTcxLjYsNDUuOTJINTRhMSwxLDAsMCwwLDAsMkg3MS42YTEsMSwwLDAsMCwwLTJaXCIgfSksXHJcbiAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTcxLjYsNDUuOTJINTRhMSwxLDAsMCwwLDAsMkg3MS42YTEsMSwwLDAsMCwwLTJaXCIgfSksXHJcbiAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IHN0eWxlOiB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTI1cHgpJyB9LCBkOiBcIk03MS4xLDY5LjQ5SDUzLjQ1YTEsMSwwLDEsMCwwLDJINzEuMWExLDEsMCwwLDAsMC0yWlwiIH0pLFxyXG4gICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk03MS4xLDY5LjQ5SDUzLjQ1YTEsMSwwLDEsMCwwLDJINzEuMWExLDEsMCwwLDAsMC0yWlwiIH0pKSk7XHJcbn07XG5cbmZ1bmN0aW9uIGdldFBvc2l0aW9uQnlQbGFjZW1lbnQocGxhY2VtZW50LCBkZWZhdWx0WCA9IDAsIGRlZmF1bHRZID0gMCkge1xyXG4gICAgY29uc3QgW3gsIHldID0gcGxhY2VtZW50LnNwbGl0KCctJyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIFt4XTogZGVmYXVsdFgsXHJcbiAgICAgICAgW3ldOiBkZWZhdWx0WSxcclxuICAgIH07XHJcbn1cblxuY29uc3QgRGV2VG9vbFVJID0gKHsgY29udHJvbCwgcGxhY2VtZW50ID0gJ3RvcC1yaWdodCcsIHN0eWxlcywgfSkgPT4ge1xyXG4gICAgY29uc3QgeyBzdGF0ZSwgYWN0aW9ucyB9ID0gbGl0dGxlU3RhdGVNYWNoaW5lLnVzZVN0YXRlTWFjaGluZSh7XHJcbiAgICAgICAgc2V0VmlzaWJsZSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgcG9zaXRpb24gPSBnZXRQb3NpdGlvbkJ5UGxhY2VtZW50KHBsYWNlbWVudCwgMCwgMCk7XHJcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChSZWFjdF9fbmFtZXNwYWNlLkZyYWdtZW50LCBudWxsLFxyXG4gICAgICAgIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChyZWFjdFNpbXBsZUFuaW1hdGUuQW5pbWF0ZSwgeyBwbGF5OiBzdGF0ZS52aXNpYmxlLCBkdXJhdGlvbjogMC4yLCBzdGFydDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwb3NpdGlvbiksIHsgcG9zaXRpb246ICdmaXhlZCcsIHRyYW5zZm9ybTogcGxhY2VtZW50LmluY2x1ZGVzKCdyaWdodCcpXHJcbiAgICAgICAgICAgICAgICAgICAgPyAndHJhbnNsYXRlWCgyODBweCknXHJcbiAgICAgICAgICAgICAgICAgICAgOiAndHJhbnNsYXRlWCgtMjgwcHgpJywgekluZGV4OiA5OTk5OSB9KSwgZW5kOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBvc2l0aW9uKSwgeyBwb3NpdGlvbjogJ2ZpeGVkJywgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgwKScsIHpJbmRleDogOTk5OTkgfSkgfSxcclxuICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwb3NpdGlvbiksIHsgcG9zaXRpb246ICdmaXhlZCcsIGhlaWdodDogJzEwMHZoJywgd2lkdGg6IDI1MCwgekluZGV4OiA5OTk5OSwgYmFja2dyb3VuZDogY29sb3JzLmJ1dHRvbkJsdWUsIGRpc3BsYXk6ICdncmlkJywgdGV4dEFsaWduOiAnbGVmdCcsIGNvbG9yOiAnd2hpdGUnLCBmb250U2l6ZTogMTQsIGdyaWRUZW1wbGF0ZVJvd3M6ICc0MHB4IGF1dG8nLCBmb250RmFtaWx5OiBcIi1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgJ1NlZ29lIFVJJywgJ1JvYm90bycsICdPeHlnZW4nLCAnVWJ1bnR1JywgJ0NhbnRhcmVsbCcsICdGaXJhIFNhbnMnLCAnRHJvaWQgU2FucycsICdIZWx2ZXRpY2EgTmV1ZScsIHNhbnMtc2VyaWZcIiB9KSwgc3R5bGVzID09PSBudWxsIHx8IHN0eWxlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3R5bGVzLnBhbmVsKSB9LFxyXG4gICAgICAgICAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KEhlYWRlciwgeyBzZXRWaXNpYmxlOiBhY3Rpb25zLnNldFZpc2libGUsIGNvbnRyb2w6IGNvbnRyb2wgfSksXHJcbiAgICAgICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUGFuZWwsIHsgY29udHJvbDogY29udHJvbCB9KSkpLFxyXG4gICAgICAgICFzdGF0ZS52aXNpYmxlICYmIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQnV0dG9uLCB7IHRpdGxlOiBcIlNob3cgZGV2IHBhbmVsXCIsIGhpZGVCYWNrZ3JvdW5kOiB0cnVlLCBzdHlsZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBwb3NpdGlvbjogJ2ZpeGVkJywgekluZGV4OiA5OTk5OSB9LCBnZXRQb3NpdGlvbkJ5UGxhY2VtZW50KHBsYWNlbWVudCwgMywgMykpLCB7IHBhZGRpbmc6IDMsIG1hcmdpbjogMCwgYmFja2dyb3VuZDogJ25vbmUnIH0pLCBzdHlsZXMgPT09IG51bGwgfHwgc3R5bGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHlsZXMuYnV0dG9uKSB9LFxyXG4gICAgICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoTG9nbywgeyBhY3Rpb25zOiBhY3Rpb25zIH0pKSkpKTtcclxufTtcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxuXG5mdW5jdGlvbiBwcm94eVRvT2JqZWN0KHByb3h5KSB7XHJcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHByb3h5KS5yZWR1Y2UoKHByZXYsIGtleSkgPT4ge1xyXG4gICAgICAgIHByZXZba2V5XSA9IHByb3h5W2tleV07XHJcbiAgICAgICAgcmV0dXJuIHByZXY7XHJcbiAgICB9LCB7fSk7XHJcbn1cclxuZnVuY3Rpb24gbmVzdFRvRmxhdChmbGF0S2V5cywgb2JqLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgIHJldHVybiBmbGF0S2V5cy5yZWR1Y2UoKHByZXYsIG5hbWUpID0+IHtcclxuICAgICAgICAvLyBuZXN0ZWQgZmllbGQgbWF5IGJlIGB1bmRlZmluZWRgXHJcbiAgICAgICAgcHJldltuYW1lXSA9IGdldF9fZGVmYXVsdFtcImRlZmF1bHRcIl0ob2JqLCBuYW1lKSB8fCBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIHByZXY7XHJcbiAgICB9LCB7fSk7XHJcbn1cblxuZnVuY3Rpb24gdXNlRXhwb3J0Q29udHJvbFRvRXh0ZW5zaW9uKHsgaWQsIGNvbnRyb2wsIH0pIHtcclxuICAgIGNvbnN0IG5lc3RlZEZvcm1WYWx1ZXMgPSB1c2VXYXRjaCh7IGNvbnRyb2wgfSk7XHJcbiAgICBjb25zdCBmb3JtU3RhdGUgPSB1c2VGb3JtU3RhdGUoeyBjb250cm9sIH0pO1xyXG4gICAgY29uc3QgW2lzRXh0ZW5zaW9uRW5hYmxlZCwgc2V0SXNFeHRlbnNpb25FbmFibGVkXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IGhhbmRsZUluaXRNZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcclxuICAgICAgICBpZiAobWVzc2FnZS5kYXRhLnNvdXJjZSAhPT0gJ3JlYWN0LWhvb2stZm9ybS1icmlkZ2UnIHx8XHJcbiAgICAgICAgICAgIG1lc3NhZ2UuZGF0YS50eXBlICE9PSAnSU5JVCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICBzb3VyY2U6ICdyZWFjdC1ob29rLWZvcm0tYnJpZGdlJyxcclxuICAgICAgICAgICAgdHlwZTogJ1dFTENPTUUnLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNldElzRXh0ZW5zaW9uRW5hYmxlZCh0cnVlKTtcclxuICAgIH07XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlSW5pdE1lc3NhZ2UpO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZUluaXRNZXNzYWdlKTtcclxuICAgIH0sIFtdKTtcclxuICAgIHVzZURlZXBDb21wYXJlRWZmZWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXSgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFpc0V4dGVuc2lvbkVuYWJsZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBfYSA9IHByb3h5VG9PYmplY3QoZm9ybVN0YXRlKSwgeyBlcnJvcnM6IG5lc3RlZEVycm9ycywgZGlydHlGaWVsZHM6IG5lc3RlZERpcnR5RmllbGRzLCB0b3VjaGVkRmllbGRzOiBuZXN0ZWRUb3VjaGVkRmllbGRzIH0gPSBfYSwgZm9ybVN0YXR1cyA9IF9fcmVzdChfYSwgW1wiZXJyb3JzXCIsIFwiZGlydHlGaWVsZHNcIiwgXCJ0b3VjaGVkRmllbGRzXCJdKTtcclxuICAgICAgICBjb25zdCBmbGF0RmllbGROYW1lcyA9IFsuLi5jb250cm9sLl9uYW1lcy5tb3VudF07XHJcbiAgICAgICAgY29uc3QgZm9ybVZhbHVlcyA9IG5lc3RUb0ZsYXQoZmxhdEZpZWxkTmFtZXMsIG5lc3RlZEZvcm1WYWx1ZXMsICcnKTtcclxuICAgICAgICBjb25zdCBkaXJ0eUZpZWxkcyA9IG5lc3RUb0ZsYXQoZmxhdEZpZWxkTmFtZXMsIG5lc3RlZERpcnR5RmllbGRzLCBmYWxzZSk7XHJcbiAgICAgICAgY29uc3QgdG91Y2hlZEZpZWxkcyA9IG5lc3RUb0ZsYXQoZmxhdEZpZWxkTmFtZXMsIG5lc3RlZFRvdWNoZWRGaWVsZHMsIGZhbHNlKTtcclxuICAgICAgICBjb25zdCBmbGF0RXJyb3JzID0gbmVzdFRvRmxhdChmbGF0RmllbGROYW1lcywgbmVzdGVkRXJyb3JzKTtcclxuICAgICAgICBjb25zdCBlcnJvcnMgPSBPYmplY3QuZW50cmllcyhmbGF0RXJyb3JzKS5yZWR1Y2UoKHByZXYsIFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICAgICAgICBwcmV2W2tleV0gPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUudHlwZSxcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS5tZXNzYWdlLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gcHJldjtcclxuICAgICAgICB9LCB7fSk7XHJcbiAgICAgICAgY29uc3QgbmF0aXZlRmllbGRzID0gZmxhdEZpZWxkTmFtZXMucmVkdWNlKChwcmV2LCBuYW1lKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgICAgICBwcmV2W25hbWVdID0gISEoKF9jID0gKF9iID0gKF9hID0gZ2V0X19kZWZhdWx0W1wiZGVmYXVsdFwiXShjb250cm9sLl9maWVsZHMsIG5hbWUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX2YpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZWYpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50eXBlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByZXY7XHJcbiAgICAgICAgfSwge30pO1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZU1lc3NhZ2VQYXlsb2FkID0ge1xyXG4gICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgZm9ybVZhbHVlcyxcclxuICAgICAgICAgICAgICAgIGZvcm1TdGF0ZTogT2JqZWN0LmFzc2lnbih7IGVycm9ycyxcclxuICAgICAgICAgICAgICAgICAgICBkaXJ0eUZpZWxkcyxcclxuICAgICAgICAgICAgICAgICAgICB0b3VjaGVkRmllbGRzLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUZpZWxkcyB9LCBmb3JtU3RhdHVzKSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgIHNvdXJjZTogJ3JlYWN0LWhvb2stZm9ybS1icmlkZ2UnLFxyXG4gICAgICAgICAgICB0eXBlOiAnVVBEQVRFJyxcclxuICAgICAgICAgICAgcGF5bG9hZDogdXBkYXRlTWVzc2FnZVBheWxvYWQsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LCBbaXNFeHRlbnNpb25FbmFibGVkLCBuZXN0ZWRGb3JtVmFsdWVzLCBwcm94eVRvT2JqZWN0KGZvcm1TdGF0ZSldKTtcclxuICAgIHJldHVybiB7IGlzRXh0ZW5zaW9uRW5hYmxlZCB9O1xyXG59XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgbGl0dGxlU3RhdGVNYWNoaW5lLmNyZWF0ZVN0b3JlKHtcclxuICAgICAgICB2aXNpYmxlOiBmYWxzZSxcclxuICAgICAgICBpc0NvbGxhcHNlOiBmYWxzZSxcclxuICAgICAgICBmaWx0ZXJOYW1lOiAnJyxcclxuICAgIH0sIHtcclxuICAgICAgICBuYW1lOiAnX19SRUFDVF9IT09LX0ZPUk1fREVWVE9PTFNfXycsXHJcbiAgICAgICAgbWlkZGxlV2FyZXM6IFtdLFxyXG4gICAgICAgIHN0b3JhZ2VUeXBlOiB3aW5kb3cubG9jYWxTdG9yYWdlLFxyXG4gICAgfSk7XHJcbn1cclxuY29uc3QgRGV2VG9vbCA9IChwcm9wcykgPT4ge1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICBjb25zdCBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQoKTtcclxuICAgIGNvbnN0IHV1aWQkMSA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKCcnKTtcclxuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICB1dWlkJDEuY3VycmVudCA9IHV1aWQudjQoKTtcclxuICAgIH0sIFtdKTtcclxuICAgIGNvbnN0IHsgaXNFeHRlbnNpb25FbmFibGVkIH0gPSB1c2VFeHBvcnRDb250cm9sVG9FeHRlbnNpb24oe1xyXG4gICAgICAgIGlkOiAoX2EgPSBwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMuaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHV1aWQkMS5jdXJyZW50LFxyXG4gICAgICAgIGNvbnRyb2w6IChfYiA9IHByb3BzID09PSBudWxsIHx8IHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wcy5jb250cm9sKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBtZXRob2RzLmNvbnRyb2wsXHJcbiAgICB9KTtcclxuICAgIGlmIChpc0V4dGVuc2lvbkVuYWJsZWQpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiAoUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KGxpdHRsZVN0YXRlTWFjaGluZS5TdGF0ZU1hY2hpbmVQcm92aWRlciwgbnVsbCxcclxuICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoRGV2VG9vbFVJLCB7IGNvbnRyb2w6IChfYyA9IHByb3BzID09PSBudWxsIHx8IHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wcy5jb250cm9sKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBtZXRob2RzLmNvbnRyb2wsIHBsYWNlbWVudDogcHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzLnBsYWNlbWVudCwgc3R5bGVzOiBwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMuc3R5bGVzIH0pKSk7XHJcbn07XG5cbmV4cG9ydHMuRGV2VG9vbCA9IERldlRvb2w7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMuZGV2ZWxvcG1lbnQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@hookform/devtools/dist/index.cjs.development.js\n");

/***/ })

};
;